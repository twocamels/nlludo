<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Nigerian Ludo 3D - Smart AI</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
  
  /* ANDROID 7 FIX: position: fixed helps stabilize the viewport */
  html, body { 
      width: 100%; height: 100%; 
      overflow: hidden; 
      background: #000; 
      touch-action: none; /* Disables default zoom/scroll globally */
      font-family: 'Poppins', sans-serif;
      position: fixed; 
      top: 0; left: 0;
  }
  
  #c { display: block; width: 100%; height: 100%; outline: none; }
    
  /* UI LAYER */
  #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

  /* GAME TITLE */
  #game-title-container {
    position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; pointer-events: none; z-index: 5;
  }
  #game-title {
    display: flex; align-items: center; gap: 8px; font-size: clamp(20px, 5vw, 32px); font-weight: 900; color: white;
    text-transform: uppercase; background: rgba(0,0,0,0.4); border: 2px solid white;
    padding: 8px 16px; backdrop-filter: blur(4px); box-shadow: 0 0 20px rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }
  .ng-flag {
    width: clamp(30px, 8vw, 40px); height: clamp(20px, 5vw, 28px);
    background: linear-gradient(90deg, #008751 33%, #ffffff 33%, #ffffff 66%, #008751 66%);
    border: 1px solid #fff; box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }

  /* TOP CONTROLS */
  #top-controls {
      position: absolute; top: 15px; right: 15px;
      display: flex; flex-direction: column; gap: 10px;
      align-items: flex-end; 
      pointer-events: auto; z-index: 20;
  }
  .top-btn { 
    background: #3a3a4a; color: white;
    padding: 0 16px !important; font-size: 11px !important; height: 36px !important;
    display: flex !important; align-items: center; justify-content: center;
    font-weight: 700; border-radius: 50px !important;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; text-align: center;
    min-width: 90px; transition: transform 0.1s; text-transform: uppercase;
  }
  .top-btn:active { transform: scale(0.95); background: #4a4a5a; }
  #btn-rules { border: 2px solid #ff9966; color: #ffccaa; }
  #btn-fx { border: 2px solid #00d2ff; color: #ccf5ff; }
  #btn-penalty { border: 2px solid #00e676; color: #ccffdd; }

  /* STATUS PANEL - DESKTOP */
  #status-panel {
    position: absolute; top: 70px; left: 10px;
    background: rgba(20, 20, 35, 0.9); backdrop-filter: blur(15px);
    padding: 12px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.15);
    color: white; 
    font-size: clamp(12px, 3vw, 14px);
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
    pointer-events: none; min-width: 160px; max-width: 200px; transition: all 0.3s ease;
    z-index: 10;
  }
    
  .status-header {
      font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; color: #888; font-weight:bold;
  }

  #player-list { display: flex; flex-direction: column; }

  .player-row {
    display: flex; justify-content: space-between; align-items: center; padding: 4px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05); opacity: 0.5; transition: all 0.3s;
    font-size: clamp(11px, 2.5vw, 13px);
  }
  .player-row.active {
    opacity: 1; font-weight: bold; 
    background: linear-gradient(90deg, rgba(255,255,255,0.1), transparent);
    padding-left: 6px; border-radius: 4px; border-left: 3px solid white;
  }
    
  .p-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 0; box-shadow: 0 0 5px currentColor; }
    
  /* Desktop text elements */
  .p-text { margin-left: 8px; font-weight: bold; color: white; }
  .p-stat { font-size: 11px; margin-left: auto; }
    
  /* Icon defaults */
  .p-icon-wrap { width: 20px; height: 20px; position: relative; display: none; margin-left:5px; } 

  /* HUMAN ICON CSS ART */
  .human-face {
      width: 14px; height: 14px; background: #ffccaa; border-radius: 50%; position: absolute; top: 3px; left: 3px;
  }
  .human-hair {
      width: 16px; height: 8px; background: #443300; border-radius: 10px 10px 0 0; position: absolute; top: 1px; left: 2px; z-index: 2;
  }
  .human-glasses {
      width: 14px; height: 4px; position: absolute; top: 7px; left: 3px; z-index: 3;
      display: flex; justify-content: center; gap: 1px;
  }
  .glass-lens {
      width: 5px; height: 4px; background: rgba(0,0,0,0.8); border: 1px solid white; border-radius: 2px;
  }

  /* DICE DISPLAY */
  #dice-container {
      margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px; text-align:center;
      display: none; /* Hidden by default (start screen) */
  }
  #d {
      font-size: clamp(22px, 6vw, 28px); color: #ffdb58; font-weight: 900; text-shadow: 0 0 10px rgba(255, 219, 88, 0.3);
      transition: all 0.3s;
  }

  /* CONTROLS */
  #controls {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: none; 
    gap: 8px; pointer-events: auto;
    padding: 15px; background: radial-gradient(circle, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0) 70%);
    border-radius: 30px; flex-wrap: wrap; justify-content: center; max-width: 95vw; z-index: 50;
  }
  button {
    display: flex; align-items: center; justify-content: center;
    height: 48px; padding: 0 20px; 
    font-size: clamp(13px, 3.5vw, 15px); font-weight: bold; font-family: 'Poppins', sans-serif;
    border: none; border-radius: 50px; cursor: pointer; color: white;
    box-shadow: 0 8px 16px rgba(0,0,0,0.4); transition: transform 0.1s;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3); white-space: nowrap;
  }
  #roll { background: #888; min-width: 130px; flex: 1; max-width: 180px; }
  .btn-ui { background: #3a3a4a; border: 1px solid #555; min-width: 80px; }
  #mode-btn { border: 2px solid #667eea; flex: 1; max-width: 160px; }
  button:active { transform: scale(0.95); }
  button:disabled { opacity: 0.7; filter: grayscale(50%); transform: scale(0.98); }

  /* SETUP SCREEN */
  #setup {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, #2a2a40, #111);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: white; z-index: 100; padding: 20px;
  }
  .setup-sel {
    padding: 12px 20px; font-size: clamp(16px, 4vw, 18px); border-radius: 15px;
    background: rgba(20,20,35,0.9); color: white; border: 2px solid #667eea;
    margin-bottom: 15px; outline: none; width: 90%; max-width: 350px; text-align: center;
  }
    
  .setup-btn {
      width: 90%; max-width: 250px; padding: 16px;
      font-size: 18px; font-weight: bold; font-family: 'Poppins', sans-serif;
      border: none; border-radius: 50px; cursor: pointer; color: white;
      margin-top: 10px; height: auto;
      text-transform: uppercase;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      transition: transform 0.1s;
  }
  .setup-btn:active { transform: scale(0.95); }

  /* MOBILE TOGGLE (Hidden on real mobile) */
  #mobile-toggle-btn {
      position: absolute; top: 20px; right: 20px;
      background: rgba(255,255,255,0.1) !important;
      border: 1px solid rgba(255,255,255,0.3);
      width: auto !important; min-width: unset;
      padding: 8px 16px !important; font-size: 12px !important;
      margin: 0 !important; box-shadow: none;
  }

  #resume-btn {
      display: none; 
      background: linear-gradient(135deg, #ff9966, #ff5e62);
      border: 2px solid white;
      animation: pulse 2s infinite;
  }
  #newgame-btn { background: linear-gradient(135deg, #667eea, #764ba2); }

  @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(255,153,102,0.5); } 100% { transform: scale(1); } }

  /* MESSAGE POPUP */
  #m {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    pointer-events: none; color: white; font-size: clamp(18px, 5vw, 24px); font-weight: 900;
    text-transform: uppercase; text-shadow: 0 4px 10px rgba(0,0,0,0.8);
    background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 50px;
    border: 2px solid rgba(255,255,255,0.2); opacity: 0; transition: opacity 0.15s;
    z-index: 100; max-width: 90%;
  }
  #m:not(:empty) { opacity: 1; transform: translate(-50%, -60%); }

  /* RULES - SCROLLABLE & POSITIONED HIGH */
  #rules {
    position: fixed; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); /* Centered better */
    
    background: rgba(25, 25, 40, 0.98); 
    color: white; 
    padding: 25px; 
    border-radius: 20px;
    width: 90%; 
    max-width: 450px; 
    display: none; 
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 20px 60px rgba(0,0,0,1); 
    z-index: 200; 
    
    /* SCROLL FIXES */
    max-height: 85vh; 
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; 
    touch-action: pan-y; /* CRITICAL: Allows vertical scroll even if body prevents it */
  }
  .close { 
      float: right; cursor: pointer; font-size: 32px; color: #ff5e62; 
      padding: 0 10px;
  }

  /* --- MOBILE OPTIMIZATIONS --- */
  .mobile-active #status-panel {
        top: 10px; left: 10px; min-width: unset; width: auto; max-width: unset;
        background: transparent; border: none; box-shadow: none;
        backdrop-filter: none; padding: 0; z-index: 12;
    }
  .mobile-active .status-header { display: none; }
  .mobile-active #player-list { flex-direction: row; gap: 8px; }
  .mobile-active .player-row {
        width: 36px; height: 36px; border-radius: 50%;
        background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.2);
        display: flex; align-items: center; justify-content: center; padding: 0;
        backdrop-filter: blur(4px); position: relative;
    }
  .mobile-active .player-row.active {
        transform: scale(1.15); border: 2px solid white; box-shadow: 0 0 15px rgba(255,255,255,0.4);
        background: rgba(0,0,0,0.6); padding: 0;
    }
  .mobile-active .p-text, .mobile-active .p-stat { display: none; } 
  .mobile-active .p-dot { 
        display: block !important; position: absolute; top: 0px; right: 0px; 
        width: 10px; height: 10px; border: 1px solid white; z-index: 5;
    }
  .mobile-active .p-icon-wrap { display: block; margin: 0; transform: scale(0.9); }
  .mobile-active #top-controls { top: 10px; right: 10px; gap: 6px; z-index: 12; }
  .mobile-active .top-btn { padding: 0 8px !important; height: 32px !important; font-size: 10px !important; min-width: 60px; }
  .mobile-active #game-title-container { top: 10px; z-index: 1; pointer-events: none; }
  .mobile-active #game-title { font-size: 16px; padding: 4px 10px; border-width: 1px; }
  .mobile-active .ng-flag { width: 20px; height: 14px; }
  .mobile-active #dice-container {
        position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
        border: none; margin: 0; padding: 0; width: 100%; pointer-events: none;
        text-align: center; z-index: 40;
    }
  .mobile-active #d {
        font-size: 20px; white-space: nowrap;
        background: rgba(0,0,0,0.4); padding: 4px 20px;
        border-radius: 20px; backdrop-filter: blur(2px);
        border: 1px solid rgba(255,255,255,0.1); display: inline-block;
    }
  .mobile-active .desktop-only { display: none; }
  .mobile-active #controls { bottom: 10px; gap: 6px; padding: 8px; width: 95%; }
  .mobile-active button { padding: 0 14px; font-size: 13px; height: 44px; }
  .mobile-active .player-row.vacant { display: none !important; }
</style>
</head>
<body>

<div id="setup">
    <button id="mobile-toggle-btn" class="setup-btn" onclick="toggleMobileView()">MOBILE UI: OFF</button>

    <div style="display:flex; align-items:center; gap:15px; margin-bottom: 20px; border: 4px solid white; padding: 15px 25px; box-shadow: 0 0 50px rgba(255,255,255,0.2);">
        <div class="ng-flag" style="transform: scale(1.2);"></div>
        <div style="font-size: clamp(32px, 10vw, 50px); font-weight: 900; text-transform:uppercase;">NG LUDO</div>
    </div>
    
    <label style="color:#aaa; margin-bottom:5px; font-size:12px; text-transform:uppercase; letter-spacing:1px;">Select Players</label>
    <select id="gameModeSelect" class="setup-sel">
        <option value="2,1" selected>Duel (1 Player vs 1 AI)</option>
        <option value="4,1">Classic (1 Player vs 3 AI)</option>
        <option value="2,2">2 Humans (PvP)</option>
        <option value="4,2">Tag Team (2 Humans vs 2 AI)</option>
        <option value="4,4">Party (4 Humans)</option>
    </select>
    
    <button id="resume-btn" class="setup-btn" onclick="restoreGame()">RESUME GAME</button>
    <button id="newgame-btn" class="setup-btn" onclick="startGame(false)">NEW GAME</button>
</div>

<canvas id="c"></canvas>

<div id="ui-layer">
  <div id="game-title-container">
      <div id="game-title">
          <div class="ng-flag"></div>
          <span>NG LUDO</span>
      </div>
  </div>
  
  <div id="top-controls">
      <button id="btn-rules" class="top-btn" onclick="document.getElementById('rules').style.display='block'">RULES</button>
      <button id="btn-fx" class="top-btn" onclick="toggleFx()">FX: HIGH</button>
      <button id="btn-penalty" class="top-btn" onclick="togglePenaltyMode()">QUICKER:GAME</button>
  </div>
  
  <div id="status-panel">
    <div class="status-header">Game Status</div>
    <div id="player-list"></div>
    
    <div id="dice-container">
        <div style="font-size: 11px; color:#aaa; margin-bottom:5px;" class="desktop-only">TOTAL ROLL</div>
        <div id="d">-</div>
    </div>
  </div>

  <div id="m"></div>

  <div id="controls">
    <button id="roll">ROLL DICE</button>
    <button id="mode-btn" class="btn-ui" onclick="toggleMode()">ADDITIVE</button>
    <button class="btn-ui" onclick="resetConfirm()">RESET</button>
  </div>
</div>

<div id="rules">
  <span class="close" onclick="this.parentElement.style.display='none'">&times;</span>
  <h2 style="color:#ff9966;">How to Play</h2>
  <div id="dynamic-rules" style="line-height: 1.6; margin: 10px 0 0 10px; font-size: 14px;"></div>
  <div style="height: 20px;"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
// --- GLOBAL CONFIG ---
// Simple mobile detection
const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
let forceMobile = false;

// Auto-hide Mobile UI button on real mobile devices
if(isMobileDevice) {
    document.getElementById('mobile-toggle-btn').style.display = 'none';
}

function applyMobileClasses() {
    if(isMobileDevice || forceMobile) document.body.classList.add('mobile-active');
    else document.body.classList.remove('mobile-active');
}
// Force resize calc on load to prevent black screen issue
window.addEventListener('load', () => { 
    applyMobileClasses();
    onWindowResize();
});
window.addEventListener('resize', () => { 
    if(!forceMobile) applyMobileClasses(); 
    onWindowResize();
});

function toggleMobileView() {
    forceMobile = !forceMobile;
    document.getElementById('mobile-toggle-btn').innerText = `MOBILE UI: ${forceMobile ? 'ON' : 'OFF'}`;
    applyMobileClasses();
    defaultCamPos = getCameraPos();
    targetCamPos.copy(defaultCamPos);
    onWindowResize();
}

function onWindowResize() {
    if(!cam || !rend) return;
    cam.aspect = window.innerWidth / window.innerHeight;
    cam.updateProjectionMatrix();
    rend.setSize(window.innerWidth, window.innerHeight);
    // Explicitly set style to avoid scaling issues
    rend.domElement.style.width = '100%';
    rend.domElement.style.height = '100%';
}

// --- LOCAL STORAGE HELPERS ---
const SAVE_KEY = 'ngLudo3D_save_v5';
const SETTINGS_KEY = 'ngLudo3D_settings_v5';

let penaltyMode = 'quick'; // quick | slow | classic
let playerPrefs = [true, true, true, true]; // Per player additive preference

function saveSettings() {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify({ fxMode, playerPrefs, penaltyMode }));
}

function loadSettings() {
    const s = localStorage.getItem(SETTINGS_KEY);
    if(s) {
        const data = JSON.parse(s);
        fxMode = data.fxMode || 'high';
        if(data.playerPrefs) playerPrefs = data.playerPrefs;
        penaltyMode = data.penaltyMode || 'quick';
        updateSettingsUI();
        updatePenaltyUI();
    }
}

function saveGame() {
    if(!gameActive) return;
    const pieceData = pieces.map(p => ({
        p: p.p, id: p.id, pos: p.pos, home: p.home, 
        hPath: p.hPath, hIdx: p.hIdx, fin: p.fin
    }));
    const data = { activePlayers, humanPlayers, curP, pieceData, gameActive: true, penaltyMode, playerPrefs };
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    document.getElementById('resume-btn').style.display = 'block';
}

function clearSave() {
    localStorage.removeItem(SAVE_KEY);
    document.getElementById('resume-btn').style.display = 'none';
}

function updateSettingsUI() {
    const fxBtn = document.getElementById('btn-fx');
    if(fxMode === 'high') {
        fxBtn.textContent = "FX: HIGH"; fxBtn.style.borderColor = "#00d2ff"; fxBtn.style.color = "#ccf5ff";
        defaultCamPos = getCameraPos();
    } else if(fxMode === 'med') {
        fxBtn.textContent = "FX: MED"; fxBtn.style.borderColor = "#00d2ff"; fxBtn.style.color = "#ccf5ff";
        defaultCamPos = getCameraPos();
    } else {
        fxBtn.textContent = "FX: OFF"; fxBtn.style.borderColor = "#555"; fxBtn.style.color = "#aaa";
        defaultCamPos = getFxOffCamPos();
    }
    targetCamPos.copy(defaultCamPos);
    
    const modeBtn = document.getElementById('mode-btn');
    const isCurAdditive = playerPrefs[curP];
    
    if(isCurAdditive) {
        modeBtn.innerText = "ADDITIVE"; modeBtn.style.borderColor = "#667eea"; modeBtn.style.color = "white";
    } else {
        modeBtn.innerText = "INDIVIDUAL"; modeBtn.style.borderColor = "#ff9966"; modeBtn.style.color = "#ff9966";
    }
}

function updatePenaltyUI() {
    const pBtn = document.getElementById('btn-penalty');
    let label = '';
    if(penaltyMode === 'quick') label = 'QUICKER:GAME';
    else if(penaltyMode === 'slow') label = 'QUICK:GAME';
    else label = 'CLASSIC:GAME';
    pBtn.textContent = label;
    updateRulesText();
}

function togglePenaltyMode() {
    if (penaltyMode === 'quick') penaltyMode = 'slow';
    else if (penaltyMode === 'slow') penaltyMode = 'classic';
    else penaltyMode = 'quick';
    saveSettings();
    updatePenaltyUI();
}

function updateRulesText() {
    const d = document.getElementById('dynamic-rules');
    
    // Determine dynamic rule text based on current mode
    let startRule = (penaltyMode === 'classic') ? "Must roll a raw <b>6</b> (single die) to leave base." : "You don't need a 6 to start. Any roll works!";
    let capRule = "";
    if (penaltyMode === 'classic') capRule = "Captured pieces go <b>all the way home</b>.";
    else if (penaltyMode === 'quick') capRule = "Captured pieces go <b>back 12 squares</b>.";
    else capRule = "Captured pieces go <b>back 20 squares</b>.";

    d.innerHTML = `
        <ul style="list-style-type: square; margin-bottom: 20px;">
            <li><b>Start:</b> ${startRule}</li>
            <li><b>Safe Spots:</b> <span style="color:#ffd700;">Gold stars</span> are safe.</li>
            <li><b>Capture:</b> ${capRule}</li>
            <li><b>Victory:</b> Get all 4 pieces to the center.</li>
        </ul>

        <h3 style="color:#00e676; margin-bottom:8px; border-top:1px solid #444; padding-top:10px;">Game Modes</h3>
        <p style="font-size:12px; color:#ccc; margin-bottom:10px;">Toggle with the green button:</p>
        <ul style="list-style-type: none; padding:0; gap:8px; display:flex; flex-direction:column;">
            <li><strong style="color:#00e676">QUICKER:</strong> No 6 needed. Capture = -12 steps.</li>
            <li><strong style="color:#00e676">QUICK:</strong> No 6 needed. Capture = -20 steps.</li>
            <li><strong style="color:#00e676">CLASSIC:</strong> Need 6 to start. Capture = Reset to base.</li>
        </ul>

        <h3 style="color:#00d2ff; margin-bottom:8px; border-top:1px solid #444; padding-top:10px;">Experience Settings</h3>
        <p style="font-size:12px; color:#ccc; margin-bottom:10px;">Toggle the FX button to change modes:</p>
        <ul style="list-style-type: square; margin-left:15px; margin-bottom:15px;">
            <li><b style="color:#00d2ff">HIGH:</b> Full immersion. Dynamic camera zooms, character personalities & unique sounds.</li>
            <li><b style="color:#00d2ff">MED:</b> Balanced. Standard animations, reduced camera motion.</li>
            <li><b style="color:#00d2ff">OFF:</b> Fast. Minimal motion, lazy camera follow, soft sounds.</li>
        </ul>

        <h3 style="color:#aa88ff; margin-bottom:8px;">Team Personalities</h3>
        <p style="font-size:12px; color:#ccc; margin-bottom:5px;">Visible in High Mode:</p>
        <ul style="list-style-type: none; padding:0;">
            <li><span style="color:#ff5e62">‚óè RED:</span> <b>Heavy</b> ‚Äì Industrial sounds + Sliding stomps.</li>
            <li><span style="color:#33ff33">‚óè GREEN:</span> <b>Organic</b> ‚Äì Wood sounds + High leaps.</li>
            <li><span style="color:#ffff33">‚óè YELLOW:</span> <b>Retro</b> ‚Äì 8-bit Beeps + Standard hops.</li>
            <li><span style="color:#5555ff">‚óè BLUE:</span> <b>Bubble</b> ‚Äì Water sounds + Double-hops.</li>
        </ul>
    `;
}

function resetConfirm() {
    if(!gameActive) {
        clearSave(); location.reload();
        return;
    }
    if(confirm("Are you sure? This will lose current progress.")) {
        clearSave(); location.reload();
    }
}

let fxMode = 'high';

// --- AUDIO ENGINE WITH HARMONICS ---
const SoundGen = {
    ctx: null,
    woodScale: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25], 
    init: function() {
        if(!this.ctx) {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (AC) this.ctx = new AC();
        }
        if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    playNote: function(freq, type, dur, vol=0.3, slideTo=null) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + dur);
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + dur + 0.1);
    },
    roll: function() { 
        if(!this.ctx) return;
        const t = this.ctx.currentTime;
        
        // Helper to create a sharp "clack" (rock on wood) sound
        const clack = (offset, pitch, vol) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            // Square wave gives the hardness/body of a solid object
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(pitch, t + offset);
            
            // Lowpass filter simulates the wooden board absorbing high frequencies
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, t + offset);

            gain.gain.setValueAtTime(0, t + offset);
            gain.gain.linearRampToValueAtTime(vol, t + offset + 0.01); // Fast attack
            gain.gain.exponentialRampToValueAtTime(0.001, t + offset + 0.1); // Fast decay

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.start(t + offset);
            osc.stop(t + offset + 0.15);
        };

        // RHYTHM: A few quick impacts to simulate tumbling
        // High pitch (800-950Hz) simulates "small rocks"
        clack(0, 800, 0.3);
        clack(0.08, 950, 0.3);
        clack(0.14, 850, 0.2);
        clack(0.25, 700, 0.1); // Final settle
    },
    step: function(pid) { 
        if(fxMode === 'off') { this.playNote(200, 'sine', 0.05, 0.1); return; }
        let sndId = (fxMode === 'med') ? 0 : pid;
        if(sndId === 1) { 
            const freq = this.woodScale[Math.floor(Math.random() * this.woodScale.length)];
            this.playNote(freq, 'sine', 0.1, 0.5, freq - 20); 
            this.playNote(freq * 0.5, 'sine', 0.05, 0.2); 
        } 
        else if(sndId === 3) { 
            const freq = 300 + Math.random()*200;
            this.playNote(freq, 'sine', 0.15, 0.4, freq - 100); 
        }
        else if(sndId === 0) { 
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);
            filter.type = 'lowpass'; filter.frequency.value = 300; 
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
            osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + 0.15);
        }
        else { 
            const tones = [523.25, 587.33, 659.25, 783.99];
            const f = tones[Math.floor(Math.random()*tones.length)];
            this.playNote(f, 'sine', 0.12, 0.15); 
        }
    },
    home: function() { 
        if(fxMode === 'off') return;
        [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => { setTimeout(() => this.playNote(f, 'triangle', 0.6, 0.3), i*80); });
    },
    capture: function() { 
        if(fxMode === 'off') return;
        this.playNote(400, 'sine', 0.4, 0.4, 100); 
    },
    win: function() {
        if(fxMode === 'off') return;
        const scale = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1567.98];
        scale.forEach((f, i) => setTimeout(() => this.playNote(f, 'square', 0.4, 0.1), i*120));
    }
};

const c = document.getElementById('c');
const scene = new THREE.Scene();
const bgColor = new THREE.Color(0x1a1a2e);
scene.background = bgColor;
scene.fog = new THREE.Fog(bgColor, 15, 50);

const cam = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
const rend = new THREE.WebGLRenderer({ canvas: c, antialias: false, powerPreference: "default" });
rend.setPixelRatio(Math.min(window.devicePixelRatio, 2)); rend.setSize(window.innerWidth, window.innerHeight);

if (!isMobileDevice) { rend.shadowMap.enabled = true; rend.shadowMap.type = THREE.PCFSoftShadowMap; }

const controls = new THREE.OrbitControls(cam, rend.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.05; controls.enablePan = true;
controls.minDistance = 5; controls.maxDistance = 60;

const cols = ['RED', 'GREEN', 'YELLOW', 'BLUE'];
const hexCols = [0xff3333, 0x33ff33, 0xffff33, 0x3333ff];
const hexColsCss = ["#ff5e62", "#33ff33", "#ffff33", "#5555ff"];

let curP = 0; let humanPlayers = []; let dice = [0, 0];
let rolling = false; let moving = false;
let pieces = []; let board, d1, d2;
let activePlayers = []; let gameActive = false;
let diceQueue = [];

function getCameraPos() { return (isMobileDevice||forceMobile) ? new THREE.Vector3(0, 20, 10) : new THREE.Vector3(0, 18, 14); }
function getFxOffCamPos() { return (isMobileDevice||forceMobile) ? new THREE.Vector3(0, 15, 5) : new THREE.Vector3(0, 15, 8); }

let defaultCamPos = getCameraPos();
const defaultLookAt = new THREE.Vector3(0, 0, 0);
let targetCamPos = defaultCamPos.clone();
let targetLookAt = defaultLookAt.clone();

const mainPath = [
    [1,6],[2,6],[3,6],[4,6],[5,6],[6,5],[6,4],[6,3],[6,2],[6,1],[6,0],[7,0],[8,0],
    [8,1],[8,2],[8,3],[8,4],[8,5],[9,6],[10,6],[11,6],[12,6],[13,6],[14,6],[14,7],[14,8],
    [13,8],[12,8],[11,8],[10,8],[9,8],[8,9],[8,10],[8,11],[8,12],[8,13],[8,14],[7,14],[6,14],
    [6,13],[6,12],[6,11],[6,10],[6,9],[5,8],[4,8],[3,8],[2,8],[1,8],[0,8],[0,7],[0,6]
];
const homePaths={
    0: [[1,7],[2,7],[3,7],[4,7],[5,7]], 1: [[7,1],[7,2],[7,3],[7,4],[7,5]],
    2: [[13,7],[12,7],[11,7],[10,7],[9,7]], 3: [[7,13],[7,12],[7,11],[7,10],[7,9]]
};
const safe = [0, 8, 13, 21, 26, 34, 39, 47, 6, 19, 32, 45];

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.7);
dl.position.set(5, 20, 5); dl.castShadow = true;
dl.shadow.mapSize.width = 2048; dl.shadow.mapSize.height = 2048;
scene.add(dl);
const pl = new THREE.PointLight(0xffaa88, 0.3, 50);
pl.position.set(0, 10, 0); scene.add(pl);

function createNumCanvas(num, colorHex) {
    const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#' + colorHex.toString(16).padStart(6,'0'); ctx.fillRect(0,0,128,128);
    ctx.fillStyle = 'white'; ctx.font = 'bold 80px Arial';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(num, 64, 64);
    return new THREE.CanvasTexture(cvs);
}

function getDiceFace(num) {
    const size = 128; const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
    const ctx = cvs.getContext('2d'); ctx.fillStyle = '#fdfdfd'; ctx.fillRect(0,0,size,size);
    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 4; ctx.strokeRect(2,2,size-4,size-4);
    ctx.fillStyle = (num === 1) ? '#d32f2f' : '#222';
    const dotR = size * 0.11; const mid = size / 2; const lo = size * 0.25; const hi = size * 0.75;
    const draw = (x,y) => { ctx.beginPath(); ctx.arc(x,y,dotR,0,Math.PI*2); ctx.fill(); };
    if(num%2 !== 0) draw(mid,mid); if(num>1) { draw(lo,lo); draw(hi,hi); }
    if(num>3) { draw(hi,lo); draw(lo,hi); } if(num===6) { draw(lo,mid); draw(hi,mid); }
    return new THREE.CanvasTexture(cvs);
}

function makeStarShape(outerR, innerR) {
    const shape = new THREE.Shape();
    for(let i=0; i<10; i++){
        const r = (i%2===0) ? outerR : innerR; const a = (i/10) * Math.PI*2;
        const x = Math.cos(a + Math.PI/2) * r; const z = Math.sin(a + Math.PI/2) * r;
        if(i===0) shape.moveTo(x,z); else shape.lineTo(x,z);
    }
    shape.closePath(); return shape;
}

function makeBoard() {
  const g = new THREE.Group();
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({color: 0x252535, roughness: 0.8}));
  floor.rotation.x = -Math.PI/2; floor.position.y = -0.2; floor.receiveShadow = true; scene.add(floor);

  const base = new THREE.Mesh(new THREE.BoxGeometry(13.5, 0.3, 13.5), new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.2}));
  base.receiveShadow = true; base.castShadow = true; g.add(base);
    
  for(let x=0; x<15; x++){
    for(let z=0; z<15; z++){
      if(x >= 6 && x <= 8 && z >= 6 && z <= 8) continue;
      const px = (x-7)*0.8, pz = (z-7)*0.8;
      let matCol = 0xffffff; let isHomeTile = false; let isPathTile = false;
      if (x <= 5 && z <= 5) { matCol = hexCols[0]; isHomeTile = true; }
      else if (x >= 9 && z <= 5) { matCol = hexCols[1]; isHomeTile = true; }
      else if (x >= 9 && z >= 9) { matCol = hexCols[2]; isHomeTile = true; }
      else if (x <= 5 && z >= 9) { matCol = hexCols[3]; isHomeTile = true; }
      if((x>=1&&x<=4)&&(z>=1&&z<=4) || (x>=10&&x<=13)&&(z>=1&&z<=4) || (x>=10&&x<=13)&&(z>=10&&z<=13) || (x>=1&&x<=4)&&(z>=10&&z<=13)) { matCol=0xffffff; isHomeTile=false; }
      if((z===7&&x>0&&x<6) || (x===1&&z===6)) { matCol=hexCols[0]; isPathTile=true; }
      if((x===7&&z>0&&z<6) || (x===8&&z===1)) { matCol=hexCols[1]; isPathTile=true; }
      if((z===7&&x>8&&x<14) || (x===13&&z===8)) { matCol=hexCols[2]; isPathTile=true; }
      if((x===7&&z>8&&z<14) || (x===6&&z===13)) { matCol=hexCols[3]; isPathTile=true; }
      const isBaseCircle = ((x===2||x===4)&&(z===2||z===4)) || ((x===10||x===12)&&(z===2||z===4)) || ((x===10||x===12)&&(z===10||z===12)) || ((x===2||x===4)&&(z===10||z===12));
      if(isBaseCircle) { matCol = 0xffffff; isHomeTile = false; }
      
      const pIdx = mainPath.findIndex(p=>p[0]===x && p[1]===z);
      const isSafe = pIdx >= 0 && safe.includes(pIdx);
      const sq = new THREE.Mesh(new THREE.BoxGeometry(0.76, 0.1, 0.76), new THREE.MeshStandardMaterial({color: matCol, roughness: 0.4}));
      sq.position.set(px, 0.2, pz); sq.receiveShadow = true; sq.castShadow = true; g.add(sq);

      if(isBaseCircle) {
        const circle = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.28, 0.12, 32), new THREE.MeshStandardMaterial({color: 0xdddddd}));
        circle.position.set(px, 0.21, pz); circle.castShadow = true; g.add(circle);
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.03, 16, 32), new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
        ring.rotation.x = Math.PI/2; ring.position.set(px, 0.22, pz); g.add(ring);
      }
      if(isSafe && !isHomeTile){
        const star = new THREE.Mesh(new THREE.ExtrudeGeometry(makeStarShape(0.3, 0.15), {depth:0.05, bevelEnabled:false}), new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0xffa500, emissiveIntensity: 0.4}));
        star.rotation.x = Math.PI/2; star.position.set(px, 0.26, pz); g.add(star);
      }
    }
  }

  const triShapes = [
      [new THREE.Vector2(-1.2, -1.2), new THREE.Vector2(-1.2, 1.2), new THREE.Vector2(0, 0)],
      [new THREE.Vector2(-1.2, -1.2), new THREE.Vector2(1.2, -1.2), new THREE.Vector2(0, 0)],
      [new THREE.Vector2(1.2, -1.2), new THREE.Vector2(1.2, 1.2), new THREE.Vector2(0, 0)],
      [new THREE.Vector2(-1.2, 1.2), new THREE.Vector2(1.2, 1.2), new THREE.Vector2(0, 0)]
  ];
  
  triShapes.forEach((pts, i) => {
      const shp = new THREE.Shape(pts);
      const geo = new THREE.ExtrudeGeometry(shp, {depth: 0.1, bevelEnabled: false});
      const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: hexCols[i], roughness: 0.4}));
      mesh.rotation.x = Math.PI/2;
      mesh.position.y = 0.2; 
      mesh.receiveShadow = true;
      g.add(mesh);
  });

  return g;
}

function makeDice() {
  const mats = [1,6,2,5,3,4].map(n => new THREE.MeshStandardMaterial({map: getDiceFace(n)}));
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), mats); mesh.castShadow = true; return mesh;
}

board = makeBoard();
scene.add(board);
d1 = makeDice(); d2 = makeDice();
d1.position.set(-8, 0.4, 0); d2.position.set(-8, 0.4, 1.5);
d1.visible = false; d2.visible = false; scene.add(d1, d2);

const homes = [ [[2,2],[2,4],[4,2],[4,4]], [[10,2],[10,4],[12,2],[12,4]], [[10,10],[10,12],[12,10],[12,12]], [[2,10],[2,12],[4,10],[4,12]] ];

function initPieces(restoredData) {
    pieces = []; scene.children.filter(c => c.userData.isPiece).forEach(c => scene.remove(c));
    const src = restoredData || activePlayers.flatMap(p => [0,1,2,3].map(i => ({p, id:i})));
    src.forEach(d => createPiece(d.p, d.id, restoredData ? d : null));
}

function createPiece(p, i, state) {
    const g = new THREE.Group(); g.userData.isPiece = true;
    const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.5, 16), new THREE.MeshStandardMaterial({color: hexCols[p]}));
    cyl.castShadow = true; cyl.position.y = 0.25; g.add(cyl);
    const top = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32), new THREE.MeshStandardMaterial({map: createNumCanvas(i+1, hexCols[p]), color: 0xffffff}));
    top.rotation.y = -Math.PI/2; top.rotation.x = -Math.PI/4; top.position.y = 0.6; top.castShadow = true; g.add(top);
    
    const [bx, bz] = homes[p][i];
    g.userData.player = p; g.userData.id = i; scene.add(g);
    
    let pieceObj = { m: g, p: p, id: i, pos: -1, home: true, hPath: false, hIdx: -1, hPos: [bx, bz], fin: false, isAnimating: false };
    if (state) {
        Object.assign(pieceObj, state);
        g.position.copy(getPieceTargetPos(pieceObj));
    } else g.position.set((bx-7)*0.8, 0, (bz-7)*0.8);
    pieces.push(pieceObj);
}

function toggleMode() { 
    playerPrefs[curP] = !playerPrefs[curP];
    saveSettings(); 
    updateSettingsUI(); 
}
function toggleFx() { fxMode = (fxMode === 'high') ? 'med' : (fxMode === 'med') ? 'off' : 'high'; saveSettings(); updateSettingsUI(); }

function restoreGame() {
    const s = localStorage.getItem(SAVE_KEY);
    if(s) {
        const data = JSON.parse(s); activePlayers = data.activePlayers; humanPlayers = data.humanPlayers; curP = data.curP; gameActive = true;
        penaltyMode = data.penaltyMode || 'quick';
        if(data.playerPrefs) playerPrefs = data.playerPrefs;
        document.getElementById('setup').style.display = 'none';
        document.getElementById('controls').style.display = 'flex'; 
        document.getElementById('dice-container').style.display = 'block'; 
        initPieces(data.pieceData); updateUI(); SoundGen.init(); updateRulesText(); updatePenaltyUI();
        onWindowResize();
    }
}

function startGame(restore) {
    SoundGen.init();
    if(!restore) {
        const [tVal, hVal] = document.getElementById('gameModeSelect').value.split(',').map(Number);
        let all = [0,1,2,3].sort(() => Math.random()-0.5);
        activePlayers = all.slice(0, tVal).sort((a,b)=>a-b);
        humanPlayers = []; let pool = [...activePlayers];
        for(let k=0; k<hVal; k++) { let r=Math.floor(Math.random()*pool.length); humanPlayers.push(pool[r]); pool.splice(r,1); }
        humanPlayers.sort(); initPieces(null); curP = activePlayers[0]; clearSave();
    }
    document.getElementById('setup').style.display = 'none'; 
    document.getElementById('controls').style.display = 'flex'; 
    document.getElementById('dice-container').style.display = 'block'; 
    gameActive = true; updateUI(); SoundGen.roll(); saveGame(); updateRulesText(); updatePenaltyUI();
    onWindowResize();
}

function updateUI() {
    const list = document.getElementById('player-list'); list.innerHTML = '';
    for(let i=0; i<4; i++) {
        const div = document.createElement('div'); div.className = 'player-row';
        const isVacant = !activePlayers.includes(i);
        if(isVacant) div.classList.add('vacant'); 
        if(i === curP) div.classList.add('active');
        
        const isHuman = humanPlayers.includes(i);
        // NEW ICON: CSS Art for Humans, Emoji for Bots
        let iconHtml = 'ü§ñ';
        if(isHuman) {
            iconHtml = `
            <div class="human-face"></div>
            <div class="human-hair"></div>
            <div class="human-glasses"><div class="glass-lens"></div><div class="glass-lens"></div></div>
            `;
        }
        
        div.innerHTML = `<span class="p-dot" style="background:${hexColsCss[i]}"></span>
                         <div class="p-icon-wrap">${isHuman ? iconHtml : iconHtml}</div>
                         <span class="p-text" style="color:${hexColsCss[i]}">${cols[i]}</span>
                         <span class="p-stat">${isHuman?"HUMAN":"AI"}</span>`;
        list.appendChild(div);
    }
    const btn = document.getElementById('roll');
    btn.style.background = hexColsCss[curP]; btn.style.color = (curP === 2) ? "#000" : "#fff"; 
    
    if(!humanPlayers.includes(curP) && gameActive) {
        btn.disabled = true; btn.textContent = "AI THINKING..."; setTimeout(aiTurn, 600); 
    } else {
        btn.disabled = false; btn.textContent = `ROLL DICE`;
    }
    updateSettingsUI();
    updatePenaltyUI();
}

document.getElementById('roll').onclick = () => { if(!rolling && !moving && diceQueue.length === 0) performRoll(); };

// --- AI STRATEGY ENGINE ---
function aiTurn() { 
    // Force AI to always calculate individual moves for best results
    playerPrefs[curP] = false; 
    performRoll(); 
}

function performRoll() {
    diceQueue = []; SoundGen.roll(); rolling = true; document.getElementById('roll').disabled = true;
    if(fxMode !== 'off') { targetCamPos.copy(defaultCamPos); targetLookAt.copy(defaultLookAt); }
    
    d1.visible = true; d2.visible = true;
    
    // START POSITION: VERY CLOSE TO BOARD
    // Board floor is y=0.2, pieces are y=0.5ish. 
    // Start at y=5 so it drops quickly but is visible.
    d1.position.set(-0.6, 5, -3.5); 
    d2.position.set(0.6, 5, -3.5); 
    
    const rollType = (pieces.filter(p=>p.p===curP && p.home).length >= 3) ? 'high' : 'neutral';
    const getDie = (t) => (t==='high' && Math.random()>0.5) ? 4+Math.floor(Math.random()*3) : 1+Math.floor(Math.random()*6);
    dice = [getDie(rollType), getDie(rollType)];

    // PHYSICS VARS
    let velocity = 0; 
    let gravity = -0.05; 
    let bounceFactor = -0.4; // Less bouncy for short drop
    let floorY = 1.2; // Imaginary surface JUST above pieces

    const iv = setInterval(() => {
        // Spin logic
        d1.rotation.x += 0.4; d1.rotation.y += 0.1; 
        d2.rotation.z += 0.4; d2.rotation.y += 0.1;
        
        // Gravity Logic
        velocity += gravity;
        d1.position.y += velocity;
        d2.position.y += velocity;

        // Bounce Logic
        if(d1.position.y < floorY) {
            d1.position.y = floorY;
            d2.position.y = floorY;
            velocity *= bounceFactor;
            
            // Stop if energy is low
            if(Math.abs(velocity) < 0.05) {
                clearInterval(iv);
                d1.position.y = floorY; d2.position.y = floorY; 
                setDiceRotation(d1, dice[0]); setDiceRotation(d2, dice[1]);
                document.getElementById('d').textContent = `${dice[0]} + ${dice[1]} = ${dice[0]+dice[1]}`;
                rolling = false;

                const isAdditive = playerPrefs[curP];
                
                if(!humanPlayers.includes(curP)) {
                    // AI: Always Individual
                    diceQueue = [dice[0], dice[1]]; 
                    checkMoves(diceQueue[0]);
                } 
                else {
                    // HUMAN
                    if(isAdditive) diceQueue = [dice[0] + dice[1]]; else diceQueue = [dice[0], dice[1]];
                    checkMoves(diceQueue[0]);
                }
            }
        }
    }, 20);
}

function setDiceRotation(mesh, val) {
    mesh.rotation.set(0,0,0);
    const map = {1:[0,0,Math.PI/2], 6:[0,0,-Math.PI/2], 2:[0,0,0], 5:[Math.PI,0,0], 3:[-Math.PI/2,0,0], 4:[Math.PI/2,0,0]};
    if(map[val]) { mesh.rotation.set(...map[val]); mesh.rotation.y += Math.random()*0.5-0.25; }
}

function getValidMoves(steps) {
    return pieces.filter(p => p.p === curP && !p.fin && isValidMove(p, steps));
}

function isValidMove(pc, steps) {
    if (pc.fin) return false; 
    if (pc.home) {
        if (penaltyMode === 'classic') return steps === 6; // STRICT CLASSIC: Must be a raw 6
        return true; 
    }
    if (pc.hPath) return (pc.hIdx + steps) <= 5;
    let relPos = (pc.pos - (pc.p * 13) + 52) % 52;
    return (relPos + steps <= 56); 
}

function getPredictedPos(pc, steps) {
    let cPos = pc.pos, cHome = pc.home, cHPath = pc.hPath, cHIdx = pc.hIdx;
    for(let i=0; i<steps; i++){
        if(cHome) { cHome=false; cPos = (pc.p * 13) % 52; }
        else if(cHPath) { cHIdx++; }
        else {
             let relPos = (cPos - (pc.p * 13) + 52) % 52;
             if(relPos + 1 > 50) { cHPath = true; cHIdx = 0; } else cPos = (cPos + 1) % 52;
        }
    }
    return { pos: cPos, home: cHome, hPath: cHPath, hIdx: cHIdx, fin: (cHPath && cHIdx === 5) };
}

// Scorer for AI logic
function evaluateMoveScore(pc, steps) {
    let score = 0;
    const dest = getPredictedPos(pc, steps);
    
    // 1. SAFETY (Highest Priority)
    if (safe.includes(dest.pos)) score += 500;
    if (dest.fin) score += 1000;
    if (dest.hPath) score += 200;

    // 2. CAPTURE
    if (!dest.home && !dest.hPath && !safe.includes(dest.pos)) {
        const victims = pieces.filter(x => x.p !== curP && !x.home && !x.fin && !x.hPath && x.pos === dest.pos);
        if (victims.length > 0) score += 400;
    }

    // 3. DISTANCE FROM ENEMIES (Maximize distance from chase)
    // Find nearest enemy behind me
    let minDistBehind = 100;
    if (!dest.home && !dest.hPath) {
        pieces.forEach(x => {
            if (x.p !== curP && !x.home && !x.fin && !x.hPath) {
                // Calculate distance if they are behind us
                let dist = (dest.pos - x.pos + 52) % 52;
                if (dist < minDistBehind && dist > 0) minDistBehind = dist;
            }
        });
        // We want to maximize this distance (run away)
        score += (minDistBehind * 5);
    }
    
    // 4. LEAVE BASE
    if (pc.home) score += 50;

    return score;
}

function checkMoves(steps) {
    moving = false; 
    const possible = getValidMoves(steps);
    
    if(possible.length === 0) {
        document.getElementById('m').textContent = `Can't move ${steps}!`;
        diceQueue.shift();
        if(diceQueue.length > 0) setTimeout(() => checkMoves(diceQueue[0]), 800);
        else setTimeout(checkCollision, 800, null);
    } else {
        if(!humanPlayers.includes(curP)) { 
             setTimeout(() => {
                // AI Advanced Logic: Evaluate all moves
                // Since AI splits dice, we are deciding for the CURRENT die in the queue.
                // We pick the move that gives the highest score.
                
                let bestMove = possible[0];
                let bestScore = -1;

                possible.forEach(p => {
                    let s = evaluateMoveScore(p, steps);
                    if (s > bestScore) {
                        bestScore = s;
                        bestMove = p;
                    }
                });
                
                move(bestMove, steps);
            }, 600); 
        } else {
            const isAdditive = playerPrefs[curP];
            document.getElementById('m').textContent = isAdditive ? `Total: ${steps}` : `Die: ${steps}`;
            if(fxMode !== 'off') targetCamPos.copy(defaultCamPos);
        }
    }
}

function nextTurn() {
    d1.visible = false; d2.visible = false; rolling = false; moving = false; diceQueue = []; 
    let loops = 0; do { curP = (curP + 1) % 4; loops++; } while (!activePlayers.includes(curP) && loops < 5);
    dice = [0, 0]; document.getElementById('d').textContent = '-'; document.getElementById('m').textContent = '';
    if(fxMode !== 'off') { targetCamPos.copy(defaultCamPos); targetLookAt.copy(defaultLookAt); }
    updateUI(); saveGame();
}

function getPieceTargetPos(pc) {
    if(pc.home) return new THREE.Vector3( (pc.hPos[0]-7)*0.8, 0, (pc.hPos[1]-7)*0.8 );
    if(pc.fin) return new THREE.Vector3(0, 0, 0); 
    if(pc.hPath) {
        if(pc.hIdx === 5) return new THREE.Vector3(0,0,0);
        const [bx, bz] = homePaths[pc.p][pc.hIdx] || [7,7];
        return new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
    }
    const [bx, bz] = mainPath[pc.pos];
    return new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
}

function getMovePath(pc, mv) {
    let path = []; let t = {pos:pc.pos, home:pc.home, hPath:pc.hPath, hIdx:pc.hIdx};
    for(let i=1; i<=mv; i++) {
        let vec;
        if(t.home) { t.home=false; t.pos=(curP*13)%52; const [bx,bz]=mainPath[t.pos]; vec=new THREE.Vector3((bx-7)*0.8,0,(bz-7)*0.8); }
        else if(t.hPath) { t.hIdx++; if(t.hIdx>5)t.hIdx=5; if(t.hIdx===5) vec=new THREE.Vector3(0,0,0); else { const [bx,bz]=homePaths[curP][t.hIdx]; vec=new THREE.Vector3((bx-7)*0.8,0,(bz-7)*0.8); } }
        else {
            let rel = (t.pos-(curP*13)+52)%52;
            if(rel+1>50) { t.hPath=true; t.hIdx=0; const [bx,bz]=homePaths[curP][0]; vec=new THREE.Vector3((bx-7)*0.8,0,(bz-7)*0.8); }
            else { t.pos=(t.pos+1)%52; const [bx,bz]=mainPath[t.pos]; vec=new THREE.Vector3((bx-7)*0.8,0,(bz-7)*0.8); }
        }
        if(vec) path.push(vec);
    }
    return path;
}

function move(pc, mv) {
    if(moving) return; moving = true; pc.isAnimating = true; document.getElementById('m').textContent = '';
    
    // HIDE DICE ON MOVE START
    d1.visible = false; d2.visible = false;
    
    const path = getMovePath(pc, mv); let hopIdx = 0;
    const pid = pc.p;

    function animateHop() {
        if(hopIdx >= path.length) {
            const finalState = getPredictedPos(pc, mv);
            Object.assign(pc, finalState);
            if(pc.fin) SoundGen.home();
            
            if(fxMode === 'high') {
                const landPos = pc.m.position.clone(); targetLookAt.copy(landPos); targetCamPos.set(landPos.x, 22, landPos.z + 12); 
            }
            setTimeout(() => { diceQueue.shift(); pc.isAnimating = false; checkCollision(pc); }, 800);
            return;
        }
        const s = pc.m.position.clone(); const e = path[hopIdx];
        const m = new THREE.Vector3().lerpVectors(s, e, 0.5);

        if(fxMode === 'high') { targetLookAt.copy(e); targetCamPos.set(m.x, 8, m.z + 5); }
        else if(fxMode === 'med') { targetLookAt.copy(defaultLookAt); targetCamPos.set(m.x*0.6, 15, m.z*0.6+8); }
        else { const d = getFxOffCamPos(); targetLookAt.copy(defaultLookAt); targetCamPos.set(m.x*0.4, d.y, m.z*0.4+d.z*0.8); }

        let dur = ((isMobileDevice||forceMobile) && fxMode !== 'high') ? 150 : (fxMode==='off'?150 : (fxMode==='med'?250 : (pid===1?280 : (pid===0?200 : 300))));
        const stT = Date.now(); SoundGen.step(pid);
        
        function stepAnim() {
             const pr = Math.min((Date.now() - stT) / dur, 1);
             pc.m.position.lerpVectors(s, e, pr);
             
             if(fxMode === 'off') pc.m.position.y = Math.sin(pr*Math.PI)*0.5;
             else if (fxMode === 'med') { pc.m.position.y = Math.sin(pr*Math.PI)*1.5; pc.m.rotation.z = 0; }
             else {
                 if(pid===1) pc.m.position.y = Math.sin(pr*Math.PI)*3.5; 
                 else if(pid===0) pc.m.position.y = (pr<0.8)?0:Math.sin((pr-0.8)*5*Math.PI)*0.5;
                 else if(pid===3) pc.m.position.y = Math.sin((pr<0.5?pr*2:(pr-0.5)*2)*Math.PI)*1.5;
                 else pc.m.position.y = Math.sin(pr*Math.PI)*1.5;
                 if(pid!==0) pc.m.rotation.z = Math.sin(pr*Math.PI*2)*0.2;
             }
             if(pr < 1) requestAnimationFrame(stepAnim);
             else { pc.m.position.copy(e); pc.m.position.y=0; pc.m.rotation.z=0; hopIdx++; setTimeout(animateHop, 50); }
        }
        stepAnim();
    }
    animateHop();
}

function celebrate(wid) {
    if(fxMode==='off'||fxMode==='med') return;
    const wins = pieces.filter(p=>p.p===wid); const st=Date.now();
    function hl() { if(gameActive)return; const t=(Date.now()-st)*0.01; wins.forEach((p,i)=>p.m.position.y=Math.abs(Math.sin(t+i))); requestAnimationFrame(hl); }
    hl();
}

function checkCollision(pc) {
    saveGame();
    if(pc && !pc.fin && !pc.home && !pc.hPath && !safe.includes(pc.pos)) {
        const cap = pieces.filter(p => p !== pc && !p.home && !p.fin && !p.hPath && p.pos === pc.pos && p.p !== pc.p);
        if(cap.length > 0) {
            SoundGen.capture();
            cap.forEach(p => {
                p.isAnimating = true; 
                let goHome = true;
                let newPosIndex = -1;

                if (penaltyMode !== 'classic') {
                    const penalty = (penaltyMode === 'quick') ? 12 : 20;
                    const startIdx = p.p * 13;
                    const currentRel = (p.pos - startIdx + 52) % 52;
                    
                    if (currentRel - penalty >= 0) {
                        goHome = false;
                        newPosIndex = (startIdx + (currentRel - penalty)) % 52;
                    }
                }

                if (goHome) {
                    p.home = true; p.pos = -1;
                } else {
                    p.pos = newPosIndex;
                    p.home = false; 
                }

                const s = p.m.position.clone(); 
                let eVector;
                if (p.home) {
                    eVector = new THREE.Vector3((p.hPos[0]-7)*0.8, 0, (p.hPos[1]-7)*0.8);
                } else {
                    eVector = getPieceTargetPos(p);
                }

                let st=0; 
                function ra(){ 
                    st+=0.05; 
                    p.m.position.lerpVectors(s, eVector, st); 
                    p.m.position.y=(fxMode!=='off')?Math.sin(st*Math.PI)*3:Math.sin(st*Math.PI)*0.5; 
                    if(st<1)requestAnimationFrame(ra); 
                    else{
                        p.m.position.y=0; p.isAnimating=false; saveGame();
                    } 
                } 
                ra();
            });
        }
    }
    if(pieces.filter(p => p.p===curP && p.fin).length === 4) {
        SoundGen.win(); document.getElementById('m').innerHTML = `<span style="color:${hexColsCss[curP]}">${cols[curP]} WINS! üéâ</span>`;
        gameActive = false; clearSave(); celebrate(curP); return;
    }
    if(diceQueue.length > 0) { if(fxMode!=='off')targetCamPos.copy(defaultCamPos); moving=false; checkMoves(diceQueue[0]); }
    else {
        // Bonus Turn Logic
        if(dice.includes(6)) {
            document.getElementById('m').textContent = 'Bonus turn!'; document.getElementById('roll').disabled = false;
            dice=[0,0]; moving=false; if(fxMode!=='off')targetCamPos.copy(defaultCamPos);
            if(!humanPlayers.includes(curP)) setTimeout(aiTurn, 800);
        } else setTimeout(nextTurn, 500);
    }
}

const rc=new THREE.Raycaster(); const ms=new THREE.Vector2();
function handleInput(x,y) {
    if(rolling||moving||diceQueue.length===0||!humanPlayers.includes(curP))return;
    ms.x=(x/window.innerWidth)*2-1; ms.y=-(y/window.innerHeight)*2+1; rc.setFromCamera(ms,cam);
    const i = rc.intersectObjects(pieces.map(p=>p.m),true);
    if(i.length>0) {
        let o=i[0].object; while(o.parent&&!o.userData.isPiece)o=o.parent;
        const pc = pieces.find(p=>p.m===o);
        if(pc&&pc.p===curP&&!pc.fin) { const s=diceQueue[0]; if(isValidMove(pc,s)) move(pc,s); }
    }
}
c.addEventListener('click', e=>handleInput(e.clientX, e.clientY));
c.addEventListener('touchend', e=>{if(e.changedTouches.length>0)handleInput(e.changedTouches[0].clientX, e.changedTouches[0].clientY)}, {passive:false});

function render() {
    requestAnimationFrame(render);
    const map={}; pieces.forEach(p=>{if(p.isAnimating||p.home)return; let k=p.fin?`F${p.p}`:(p.hPath?`H${p.p}${p.hIdx}`:`M${p.pos}`); if(!map[k])map[k]=[]; map[k].push(p);});
    for(let k in map){
        let g=map[k], c=new THREE.Vector3();
        if(k[0]==='F') { const id=parseInt(k[1]); c.set(id===1||id===2?0.6:-0.6, 0.22, id===2||id===3?0.6:-0.6); } else c=getPieceTargetPos(g[0]);
        if(g.length===1) g[0].m.position.lerp(c,0.1);
        else g.forEach((p,i)=>{const a=i*((Math.PI*2)/g.length)+(Date.now()*0.0005); p.m.position.lerp(c.clone().add(new THREE.Vector3(Math.cos(a)*0.25,0,Math.sin(a)*0.25)),0.1);});
    }

    if(fxMode === 'high' && (rolling || pieces.some(p => p.isAnimating))) {
        controls.enabled = false; 
        cam.position.lerp(targetCamPos, 0.03);
        if(!window.curLook) window.curLook = defaultLookAt.clone();
        window.curLook.lerp(targetLookAt, 0.03);
        cam.lookAt(window.curLook);
    } else {
        if (!controls.enabled) { controls.target.copy(window.curLook || defaultLookAt); controls.enabled = true; }
        controls.update();
    }
    rend.render(scene, cam);
}
loadSettings(); if(localStorage.getItem(SAVE_KEY)) document.getElementById('resume-btn').style.display='block';
cam.position.copy(defaultCamPos); cam.lookAt(defaultLookAt); render();
</script>
</body>
</html>
