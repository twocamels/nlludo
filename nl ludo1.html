<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nairaland Ludo 3D - Smart Dice</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { overflow: hidden; font-family: 'Poppins', sans-serif; background: #000; }
  #c { display: block; width: 100vw; height: 100vh; }
  
  /* UI LAYER */
  #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

  /* Container for the 2D Dice results */
  #dice-result-container {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 5;
  }
  /* Style for the generated 2D dice canvases */
  .dice-2d {
      position: absolute;
      /* Center the canvas on its requested coordinate */
      transform: translate(-50%, -50%);
      box-shadow: 0 5px 15px rgba(0,0,0,0.5);
      border-radius: 12px; /* Match canvas drawing radius */
  }

  #game-title-container {
    position: absolute; top: 20px; width: 100%; display: flex; justify-content: center; pointer-events: none;
  }
  #game-title {
    display: flex; align-items: center; gap: 15px; font-size: 40px; font-weight: 900; color: white;
    text-transform: uppercase; background: rgba(0,0,0,0.4); border: 3px solid white;
    padding: 10px 30px; backdrop-filter: blur(4px); box-shadow: 0 0 20px rgba(255,255,255,0.2);
  }
  .ng-flag {
    width: 50px; height: 35px;
    background: linear-gradient(90deg, #008751 33%, #ffffff 33%, #ffffff 66%, #008751 66%);
    border: 1px solid #fff; box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }

  #btn-rules { position: absolute; top: 30px; right: 30px; pointer-events: auto; z-index: 10; }

  #status-panel {
    position: absolute; top: 130px; left: 20px;
    background: rgba(20, 20, 35, 0.9); backdrop-filter: blur(15px);
    padding: 20px; border-radius: 15px; border: 1px solid rgba(255, 255, 255, 0.15);
    color: white; font-size: 16px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
    pointer-events: none; min-width: 240px; transition: all 0.5s ease;
  }
  
  .player-row {
    display: flex; justify-content: space-between; padding: 6px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05); opacity: 0.5; transition: all 0.3s;
  }
  .player-row.active {
    opacity: 1; font-weight: bold;
    background: linear-gradient(90deg, rgba(255,255,255,0.1), transparent);
    padding-left: 8px; border-radius: 4px; border-left: 3px solid white;
  }
  .player-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; box-shadow: 0 0 5px currentColor; }

  #controls {
    position: absolute; display: flex; gap: 10px; pointer-events: auto;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    padding: 20px; background: radial-gradient(circle, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0) 70%);
    border-radius: 30px;
  }
  
  .pos-bottom-center { bottom: 40px; left: 50%; transform: translateX(-50%); flex-direction: row; }
  .pos-0 { bottom: 30px; left: 30px; flex-direction: column-reverse; } 
  .pos-1 { top: 120px; left: 30px; flex-direction: column; } 
  .pos-2 { top: 120px; right: 30px; flex-direction: column; align-items: flex-end;} 
  .pos-3 { bottom: 30px; right: 30px; flex-direction: column-reverse; align-items: flex-end; } 

  button {
    padding: 15px 30px; font-size: 16px; font-weight: bold;
    font-family: 'Poppins', sans-serif; border: none; border-radius: 50px;
    cursor: pointer; color: white;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    box-shadow: 0 10px 20px rgba(0,0,0,0.4);
    transition: transform 0.1s, box-shadow 0.1s, filter 0.2s;
  }
  #roll { background: #888; transition: background 0.3s; min-width: 150px; height: 60px;}
  .btn-ui { background: #3a3a4a; border: 1px solid #555; }
  #mode-btn { min-width: 160px; border: 2px solid #667eea; }
  
  button:hover { transform: translateY(-3px); filter: brightness(1.1); }
  button:active { transform: translateY(0); }
  button:disabled { opacity: 0.7; cursor: wait; filter: grayscale(50%); transform: scale(0.98); }

  #setup {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, #2a2a40, #111);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: white; z-index: 20;
  }
  
  #gameModeSelect {
    padding: 15px 25px; font-size: 20px; border-radius: 15px;
    background: rgba(20,20,35,0.9); color: white; border: 2px solid #667eea;
    margin-bottom: 30px; outline: none; cursor: pointer; font-family: 'Poppins', sans-serif;
    min-width: 300px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  #gameModeSelect option { background: #1a1a2e; color: white; padding: 10px; }
  
  #rules {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(25, 25, 40, 0.98); color: white;
    padding: 40px; border-radius: 20px; max-width: 500px; width: 90%; display: none;
    border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 20px 60px rgba(0,0,0,1); z-index: 15;
  }
  .close { float: right; cursor: pointer; font-size: 30px; color: #ff5e62; }
</style>
</head>
<body>

<div id="setup">
    <div style="display:flex; align-items:center; gap:20px; margin-bottom: 30px; border: 6px solid white; padding: 20px 40px; box-shadow: 0 0 50px rgba(255,255,255,0.2);">
        <div class="ng-flag" style="transform: scale(1.5);"></div>
        <div style="font-size: 60px; font-weight: 900; text-transform:uppercase;">NL LUDO</div>
    </div>
    
    <label style="color:#aaa; margin-bottom:10px; font-size:14px; text-transform:uppercase; letter-spacing:1px;">Select Game Mode</label>
    <select id="gameModeSelect">
        <option value="2,1" selected>Duel (1 Player vs 1 AI)</option>
        <option value="4,1">Classic (1 Player vs 3 AI)</option>
        <option value="2,2">2 Humans (PvP)</option>
        <option value="4,2">Tag Team (2 Humans vs 2 AI)</option>
        <option value="4,4">Party (4 Humans)</option>
    </select>
    
    <button class="btn-ui" style="background: linear-gradient(135deg, #667eea, #764ba2); border:none; margin-top:10px; font-size: 20px; width: 250px; padding: 20px;" onclick="startGame()">Start Game</button>
</div>

<canvas id="c"></canvas>

<div id="ui-layer">
  <div id="game-title-container">
      <div id="game-title">
          <div class="ng-flag"></div>
          <span>NL LUDO</span>
      </div>
  </div>
  
  <button id="btn-rules" class="btn-ui" onclick="document.getElementById('rules').style.display='block'">RULES</button>
  
  <div id="status-panel">
    <div style="font-size: 12px; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; color: #888; font-weight:bold;">Game Status</div>
    <div id="player-list"></div>
    <div style="margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px; text-align:center;">
        <div style="font-size: 14px; color:#aaa; margin-bottom:5px;">TOTAL ROLL</div>
        <div id="d" style="font-size: 32px; color: #ffdb58; font-weight: 900; text-shadow: 0 0 10px rgba(255, 219, 88, 0.3);">-</div>
        <div id="m" style="margin-top:10px; font-style: italic; min-height: 20px; color: #ccc; font-size: 14px;"></div>
    </div>
  </div>

  <div id="dice-result-container"></div>

  <div id="controls" class="pos-bottom-center">
    <button id="roll">ROLL DICE</button>
    <button id="mode-btn" class="btn-ui" onclick="toggleMode()">MODE: ADDITIVE</button>
    <button class="btn-ui" onclick="location.reload()">RESET</button>
  </div>
</div>

<div id="rules">
  <span class="close" onclick="this.parentElement.style.display='none'">&times;</span>
  <h2 style="color:#ff9966">How to Play</h2>
  <ul style="line-height: 1.8; margin-top: 10px; margin-left: 20px;">
    <li><b>Start:</b> You don't need a 6 to start. Any roll works!</li>
    <li><b>Safe Spots:</b> <span style="color:#bf5aff; font-weight:bold;">Purple</span> squares are safe from capture.</li>
    <li><b>Capture:</b> Land on an opponent to send them home.</li>
    <li><b>Victory:</b> Get all 4 pieces to the center triangle.</li>
    <li><b>Modes:</b> Use the toggle to switch between <b>Additive</b> (Dice Sum) or <b>Individual</b> (Split Moves).</li>
  </ul>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const SoundGen = {
    ctx: null,
    init: function() {
        if(!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                this.ctx = new AudioContext();
            }
        }
        if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    playNote: function(freq, type, dur, vol=0.1, slideTo=null) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slideTo) {
            osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + dur);
        }
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + dur + 0.1);
    },
    roll: function() {
        if(!this.ctx) return;
        const bufSize = this.ctx.sampleRate * 0.4;
        const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i/(bufSize/5));
        const noise = this.ctx.createBufferSource();
        noise.buffer = buf;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 800;
        const gain = this.ctx.createGain(); gain.gain.value = 0.3;
        noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
        noise.start();
    },
    step: function() { 
        if(!this.ctx) return;
        const tones = [523.25, 587.33, 659.25, 783.99];
        const f = tones[Math.floor(Math.random()*tones.length)];
        this.playNote(f, 'sine', 0.15, 0.1); this.playNote(f*2, 'triangle', 0.1, 0.05);
    },
    home: function() { 
        if(!this.ctx) return;
        [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => { setTimeout(() => this.playNote(f, 'triangle', 0.6, 0.15), i*80); });
    },
    capture: function() { 
        if(!this.ctx) return;
        this.playNote(400, 'sine', 0.4, 0.2, 100); this.playNote(405, 'triangle', 0.4, 0.1, 105);
    },
    win: function() {
        if(!this.ctx) return;
        const scale = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1567.98];
        scale.forEach((f, i) => {
             setTimeout(() => this.playNote(f, 'square', 0.4, 0.05), i*120);
             setTimeout(() => this.playNote(f, 'triangle', 0.6, 0.1), i*120);
        });
        setTimeout(() => {
            this.playNote(523.25, 'triangle', 1.5, 0.2);
            this.playNote(659.25, 'triangle', 1.5, 0.2);
            this.playNote(783.99, 'triangle', 1.5, 0.2);
        }, scale.length*120);
    }
};

const c = document.getElementById('c');
const scene = new THREE.Scene();
const bgColor = new THREE.Color(0x1a1a2e);
scene.background = bgColor;
scene.fog = new THREE.Fog(bgColor, 15, 50);

const cam = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
const rend = new THREE.WebGLRenderer({canvas:c, antialias:true});
rend.setSize(innerWidth, innerHeight);
rend.shadowMap.enabled = true;
rend.shadowMap.type = THREE.PCFSoftShadowMap;

const cols = ['RED', 'GREEN', 'YELLOW', 'BLUE'];
const hexCols = [0xff3333, 0x33ff33, 0xffff33, 0x3333ff];
const hexColsCss = ["#ff5e62", "#33ff33", "#ffff33", "#5555ff"];
const safeColorHex = 0x9933ff; 

let curP = 0; 
let humanPlayers = []; 
let dice = [0, 0];
let rolling = false; let moving = false;
let pieces = []; let board, d1, d2;
let activePlayers = []; let gameActive = false;

let isAdditive = true;
let diceQueue = [];

const defaultCamPos = new THREE.Vector3(0, 18, 14);
const defaultLookAt = new THREE.Vector3(0, 0, 0);
let targetCamPos = defaultCamPos.clone();
let targetLookAt = defaultLookAt.clone();

const mainPath = [
    [1,6], [2,6], [3,6], [4,6], [5,6], 
    [6,5], [6,4], [6,3], [6,2], [6,1], [6,0], 
    [7,0], [8,0], 
    [8,1], [8,2], [8,3], [8,4], [8,5], 
    [9,6], [10,6], [11,6], [12,6], [13,6], [14,6], 
    [14,7], [14,8], 
    [13,8], [12,8], [11,8], [10,8], [9,8], 
    [8,9], [8,10], [8,11], [8,12], [8,13], [8,14], 
    [7,14], [6,14], 
    [6,13], [6,12], [6,11], [6,10], [6,9], 
    [5,8], [4,8], [3,8], [2,8], [1,8], [0,8], 
    [0,7], [0,6] 
];

const homePaths={
    0: [[1,7],[2,7],[3,7],[4,7],[5,7]], // Red
    1: [[7,1],[7,2],[7,3],[7,4],[7,5]], // Green
    2: [[13,7],[12,7],[11,7],[10,7],[9,7]], // Yellow
    3: [[7,13],[7,12],[7,11],[7,10],[7,9]] // Blue
};
const safe = [0, 8, 13, 21, 26, 34, 39, 47];

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.7);
dl.position.set(5, 20, 5); dl.castShadow = true;
dl.shadow.mapSize.width = 2048; dl.shadow.mapSize.height = 2048;
scene.add(dl);
const pl = new THREE.PointLight(0xffaa88, 0.3, 50);
pl.position.set(0, 10, 0); scene.add(pl);

function createNumCanvas(num, colorHex) {
    const cvs = document.createElement('canvas');
    cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#' + colorHex.toString(16).padStart(6,'0');
    ctx.fillRect(0,0,128,128);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 80px Arial';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor="rgba(0,0,0,0.5)"; ctx.shadowBlur=4;
    ctx.fillText(num, 64, 64);
    return new THREE.CanvasTexture(cvs);
}

// --- 2D DICE GENERATION UTILITY ---
function create2DDiceCanvas(num) {
    const size = 80;
    const cvs = document.createElement('canvas');
    cvs.width = size; cvs.height = size;
    const ctx = cvs.getContext('2d');
    
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.roundRect(0, 0, size, size, 12);
    ctx.fill();
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = (num === 1) ? '#ff3333' : 'black'; 
    const dotSize = size / 10;
    const center = size / 2;
    const offset = size / 4;

    const drawDot = (x, y) => {
        ctx.beginPath();
        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
        ctx.fill();
    };

    if (num === 1 || num === 3 || num === 5) drawDot(center, center);
    if (num > 1) { drawDot(offset, offset); drawDot(size - offset, size - offset); }
    if (num > 3) { drawDot(size - offset, offset); drawDot(offset, size - offset); }
    if (num === 6) { drawDot(offset, center); drawDot(size - offset, center); }
    return cvs;
}

function toScreenPosition(obj, camera) {
    const vector = new THREE.Vector3();
    obj.getWorldPosition(vector);
    vector.project(camera);
    const widthHalf = 0.5 * innerWidth;
    const heightHalf = 0.5 * innerHeight;
    return { x: (vector.x * widthHalf) + widthHalf, y: -(vector.y * heightHalf) + heightHalf };
}

function makeBoard() {
  const g = new THREE.Group();
  const floorGeo = new THREE.PlaneGeometry(200, 200);
  const floorMat = new THREE.MeshStandardMaterial({color: 0x252535, roughness: 0.8});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2; floor.position.y = -0.2; floor.receiveShadow = true;
  scene.add(floor);

  const sz = 0.8;
  const baseGeo = new THREE.BoxGeometry(13.5, 0.3, 13.5);
  const baseMat = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.2});
  const base = new THREE.Mesh(baseGeo, baseMat);
  base.receiveShadow = true; base.castShadow = true; g.add(base);
  
  const safeMat = new THREE.MeshStandardMaterial({color: safeColorHex});
  
  // --- VISUAL GRID GENERATION ---
  for(let x=0; x<15; x++){
    for(let z=0; z<15; z++){
      const px = (x-7)*sz, pz = (z-7)*sz;
      let matCol = 0xf0f0f0; 

      if (x <= 5 && z <= 5) matCol = hexCols[0]; // Red
      else if (x >= 9 && z <= 5) matCol = hexCols[1]; // Green
      else if (x >= 9 && z >= 9) matCol = hexCols[2]; // Yellow
      else if (x <= 5 && z >= 9) matCol = hexCols[3]; // Blue
      
      if(z === 7 && x > 0 && x < 6) matCol = hexCols[0]; // Red Path
      if(x === 7 && z > 0 && z < 6) matCol = hexCols[1]; // Green Path
      if(z === 7 && x > 8 && x < 14) matCol = hexCols[2]; // Yellow Path
      if(x === 7 && z > 8 && z < 14) matCol = hexCols[3]; // Blue Path

      if(x===1 && z===6) matCol = hexCols[0]; // Red Start
      if(x===8 && z===1) matCol = hexCols[1]; // Green Start
      if(x===13 && z===8) matCol = hexCols[2]; // Yellow Start
      if(x===6 && z===13) matCol = hexCols[3]; // Blue Start

      // NEW: Add 4 white squares in the middle of each home
      if( (x===2 || x===3) && (z===2 || z===3) ) matCol = 0xffffff; // Red Inner
      if( (x===11 || x===12) && (z===2 || z===3) ) matCol = 0xffffff; // Green Inner
      if( (x===11 || x===12) && (z===11 || z===12) ) matCol = 0xffffff; // Yellow Inner
      if( (x===2 || x===3) && (z===11 || z===12) ) matCol = 0xffffff; // Blue Inner

      const pIdx = mainPath.findIndex(p=>p[0]===x && p[1]===z);
      if(pIdx >= 0 && safe.includes(pIdx)) {
           matCol = safeColorHex;
      }
      
      const mat = new THREE.MeshStandardMaterial({color: matCol});
      const sq = new THREE.Mesh(new THREE.BoxGeometry(sz*0.95, 0.1, sz*0.95), mat);
      sq.position.set(px, 0.2, pz); sq.receiveShadow = true; sq.castShadow = true; g.add(sq);

      if(pIdx>=0 && safe.includes(pIdx)){
        const star = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.1, 5), new THREE.MeshStandardMaterial({color: 0xffd700}));
        star.position.set(px, 0.26, pz); star.rotation.x = Math.PI/2; g.add(star);
      }
    }
  }
  
  // --- CENTER TRIANGLES ---
  const centerG = new THREE.Group();
  const triRed = new THREE.Shape(); triRed.moveTo(-1.2,-1.2); triRed.lineTo(-1.2,1.2); triRed.lineTo(0,0);
  const mRed = new THREE.Mesh(new THREE.ShapeGeometry(triRed), new THREE.MeshStandardMaterial({color: hexCols[0]}));
  mRed.rotation.x = -Math.PI/2; mRed.position.y = 0.21; centerG.add(mRed);

  const triGreen = new THREE.Shape(); triGreen.moveTo(-1.2,-1.2); triGreen.lineTo(1.2,-1.2); triGreen.lineTo(0,0);
  const mGreen = new THREE.Mesh(new THREE.ShapeGeometry(triGreen), new THREE.MeshStandardMaterial({color: hexCols[1]}));
  mGreen.rotation.x = -Math.PI/2; mGreen.position.y = 0.21; centerG.add(mGreen);

  const triYellow = new THREE.Shape(); triYellow.moveTo(1.2,-1.2); triYellow.lineTo(1.2,1.2); triYellow.lineTo(0,0);
  const mYellow = new THREE.Mesh(new THREE.ShapeGeometry(triYellow), new THREE.MeshStandardMaterial({color: hexCols[2]}));
  mYellow.rotation.x = -Math.PI/2; mYellow.position.y = 0.21; centerG.add(mYellow);

  const triBlue = new THREE.Shape(); triBlue.moveTo(-1.2,1.2); triBlue.lineTo(1.2,1.2); triBlue.lineTo(0,0);
  const mBlue = new THREE.Mesh(new THREE.ShapeGeometry(triBlue), new THREE.MeshStandardMaterial({color: hexCols[3]}));
  mBlue.rotation.x = -Math.PI/2; mBlue.position.y = 0.21; centerG.add(mBlue);
  g.add(centerG);

  // --- HIDDEN EMAIL ---
  const emailCvs = document.createElement('canvas');
  emailCvs.width = 256; emailCvs.height = 64;
  const eCtx = emailCvs.getContext('2d');
  eCtx.fillStyle = 'white'; eCtx.fillRect(0,0,256,64);
  eCtx.fillStyle = '#f0f0f0'; 
  eCtx.font = '10px Arial'; eCtx.textAlign = 'center'; eCtx.textBaseline = 'middle';
  eCtx.fillText('abdallahibako@gmail.com', 128, 32);
  const emailTex = new THREE.CanvasTexture(emailCvs);

  const finalPt = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,0.05,32), new THREE.MeshBasicMaterial({map: emailTex, color:0xffffff}));
  finalPt.position.y = 0.22; g.add(finalPt);
  return g;
}

function makeDice() {
  const g = new THREE.Group();
  const cube = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({color: 0xffffff}));
  cube.castShadow = true; g.add(cube);
  const dotMat = new THREE.MeshStandardMaterial({color:0x000000});
  const positions = [[[0,0,0.41]],[[-0.2,0.2,0.41],[0.2,-0.2,0.41]],[[-0.2,0.2,0.41],[0,0,0.41],[0.2,-0.2,0.41]],[[-0.2,0.2,0.41],[0.2,0.2,0.41],[-0.2,-0.2,0.41],[0.2,-0.2,0.41]],[[-0.2,0.2,0.41],[0.2,0.2,0.41],[0,0,0.41],[-0.2,-0.2,0.41],[0.2,-0.2,0.41]],[[-0.2,0.25,0.41],[0.2,0.25,0.41],[-0.2,0,0.41],[0.2,0,0.41],[-0.2,-0.25,0.41],[0.2,-0.25,0.41]]];
  const rots = [[0,0,0],[0,Math.PI,0],[0,-Math.PI/2,0],[0,Math.PI/2,0],[-Math.PI/2,0,0],[Math.PI/2,0,0]];
  for(let i=0; i<6; i++){
    const face = new THREE.Group();
    positions[i].forEach(p => {
      const dot = new THREE.Mesh(new THREE.SphereGeometry(0.06), dotMat);
      dot.position.set(...p); face.add(dot);
    });
    face.rotation.set(...rots[i]); g.add(face);
  }
  return g;
}

function addPathArrows() {
    const homeEnds = [homePaths[0][4], homePaths[1][4], homePaths[2][4], homePaths[3][4]]; 
    const arrowRotations = [ -Math.PI/2, 0, Math.PI/2, Math.PI ];
    for(let p=0; p<4; p++) {
        const arrowHeadGeo = new THREE.ConeGeometry(0.35, 0.5, 3); 
        const cMat = new THREE.MeshBasicMaterial({color: hexCols[p]});
        const [hx, hz] = homeEnds[p];
        const arrow = new THREE.Mesh(arrowHeadGeo, cMat);
        arrow.position.set((hx-7)*0.8, 0.26, (hz-7)*0.8);
        arrow.rotation.x = Math.PI/2; arrow.rotation.z = arrowRotations[p]; 
        board.add(arrow);
    }
}

board = makeBoard();
addPathArrows(); 
scene.add(board);
d1 = makeDice(); d2 = makeDice();
d1.position.set(-8, 1, 0); d2.position.set(-8, 1, 1.5);
d1.visible = false; d2.visible = false;
scene.add(d1, d2);

const homes = [
    [[1.5,1.5],[1.5,4.5],[4.5,1.5],[4.5,4.5]], 
    [[9.5,1.5],[9.5,4.5],[12.5,1.5],[12.5,4.5]], 
    [[9.5,9.5],[9.5,12.5],[12.5,9.5],[12.5,12.5]], 
    [[1.5,9.5],[1.5,12.5],[4.5,9.5],[4.5,12.5]]
];

function initPieces() {
    pieces = [];
    scene.children.filter(c => c.userData.isPiece).forEach(c => scene.remove(c));
    activePlayers.forEach(p => {
      for(let i=0; i<4; i++){
        const g = new THREE.Group();
        g.userData.isPiece = true;
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.5, 16), new THREE.MeshStandardMaterial({color: hexCols[p]}));
        cyl.castShadow = true; cyl.position.y = 0.25; g.add(cyl);
        const top = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32), new THREE.MeshStandardMaterial({
            map: createNumCanvas(i+1, hexCols[p]), color: 0xffffff
        }));
        top.rotation.y = -Math.PI/2; top.rotation.x = -Math.PI/4; top.position.y = 0.6; top.castShadow = true;
        g.add(top);
        const [bx, bz] = homes[p][i];
        g.position.set((bx-7)*0.8, 0, (bz-7)*0.8);
        g.userData.player = p; g.userData.id = i;
        scene.add(g);
        pieces.push({
            m: g, p: p, id: i,
            pos: -1, home: true, hPath: false, hIdx: -1, 
            hPos: [bx, bz], fin: false
        });
      }
    });
}

function toggleMode() {
    isAdditive = !isAdditive;
    const btn = document.getElementById('mode-btn');
    if(isAdditive) {
        btn.innerText = "MODE: ADDITIVE";
        btn.style.borderColor = "#667eea"; btn.style.color = "white";
    } else {
        btn.innerText = "MODE: INDIVIDUAL";
        btn.style.borderColor = "#ff9966"; btn.style.color = "#ff9966";
    }
}

function startGame() {
    try {
        SoundGen.init(); 
        const selVal = document.getElementById('gameModeSelect').value;
        const [tVal, hVal] = selVal.split(',');
        const totalP = parseInt(tVal);
        const humanCount = parseInt(hVal);
        
        activePlayers = [];
        for(let i=0; i<totalP; i++) activePlayers.push(i);
        
        let pool = [...activePlayers];
        humanPlayers = [];
        for(let k=0; k<humanCount; k++) {
            let randIdx = Math.floor(Math.random() * pool.length);
            humanPlayers.push(pool[randIdx]);
            pool.splice(randIdx, 1);
        }
        humanPlayers.sort(); 
        
        document.getElementById('setup').style.display = 'none';
        gameActive = true;
        initPieces();
        curP = 0; 
        updateUI();
        SoundGen.roll();
    } catch(e) {
        console.error("Game Start Error:", e);
        alert("Error starting game.");
    }
}

function updateUI() {
    const list = document.getElementById('player-list');
    list.innerHTML = '';
    for(let i=0; i<4; i++) {
        const div = document.createElement('div');
        div.className = 'player-row';
        if(i === curP) div.classList.add('active');
        let status = "VACANT";
        if(activePlayers.includes(i)) status = (humanPlayers.includes(i)) ? "HUMAN" : "AI";
        const colDiv = document.createElement('div');
        colDiv.innerHTML = `<span class="player-indicator" style="background:${hexColsCss[i]}"></span>${cols[i]}`;
        const statDiv = document.createElement('div'); statDiv.innerText = status;
        div.appendChild(colDiv); div.appendChild(statDiv); list.appendChild(div);
    }
    const btn = document.getElementById('roll');
    btn.style.background = hexColsCss[curP];
    btn.style.color = (curP === 2) ? "#000" : "#fff"; 
    btn.style.textShadow = (curP === 2) ? "none" : "0 2px 4px rgba(0,0,0,0.5)";
    
    const ctrls = document.getElementById('controls');
    
    if(humanPlayers.length > 1) {
        ctrls.className = ''; 
        ctrls.classList.add(`pos-${curP}`);
    } else {
        ctrls.className = 'pos-bottom-center';
    }

    if(!humanPlayers.includes(curP) && gameActive) {
        btn.disabled = true; btn.textContent = "AI TURN...";
        setTimeout(aiTurn, 1000);
    } else {
        btn.disabled = false; btn.textContent = `ROLL DICE`;
    }
}

document.getElementById('roll').onclick = () => {
    if(rolling || moving || (dice[0]!==0 && diceQueue.length > 0)) return;
    performRoll();
};

function aiTurn() { performRoll(); }

function performRoll() {
    document.getElementById('dice-result-container').innerHTML = '';
    diceQueue = [];
    SoundGen.roll();
    rolling = true;
    document.getElementById('roll').disabled = true;
    let sp = 0;
    targetCamPos.copy(defaultCamPos);
    targetLookAt.copy(defaultLookAt);

    d1.visible = true; d2.visible = true;

    const iv = setInterval(() => {
        d1.rotation.x += 0.5; d1.rotation.z += 0.3;
        d2.rotation.x += 0.3; d2.rotation.z += 0.5;
        d1.position.y = 1 + Math.sin(sp)*0.5;
        d2.position.y = 1 + Math.cos(sp)*0.5;
        if(++sp > 20){
            clearInterval(iv);
            
            // --- SMART DICE LOGIC ---
            const pPieces = pieces.filter(p => p.p === curP);
            const inBase = pPieces.filter(p => p.home).length;
            const inEndZone = pPieces.filter(p => p.hPath || p.fin).length;
            
            let rollType = 'neutral';
            if(inBase >= 3) rollType = 'high'; // Early game
            if(inEndZone >= 2) rollType = 'low'; // Late game
            
            const getDie = (type) => {
                const r = Math.random();
                if(type === 'high') {
                    if(r > 0.5) return 4 + Math.floor(Math.random()*3); 
                }
                if(type === 'low') {
                    if(r > 0.5) return 1 + Math.floor(Math.random()*3);
                }
                return 1 + Math.floor(Math.random()*6);
            };
            
            dice = [getDie(rollType), getDie(rollType)];
            
            const container = document.getElementById('dice-result-container');
            [d1, d2].forEach((d3d, i) => {
                const val = dice[i];
                const pos = toScreenPosition(d3d, cam);
                const canvas = create2DDiceCanvas(val);
                canvas.className = 'dice-2d';
                canvas.style.left = `${pos.x}px`;
                canvas.style.top = `${pos.y}px`;
                container.appendChild(canvas);
            });

            d1.visible = false; d2.visible = false;
            
            const t = dice[0] + dice[1];
            document.getElementById('d').textContent = `${dice[0]} + ${dice[1]} = ${t}`;
            rolling = false;
            
            if(isAdditive) {
                diceQueue = [dice[0] + dice[1]];
            } else {
                diceQueue = [dice[0], dice[1]];
            }
            checkMoves(diceQueue[0]);
        }
    }, 50);
}

function isValidMove(pc, steps) {
    if(pc.home) return true;
    if(pc.fin) return false;
    if(pc.hPath) return (pc.hIdx + steps) <= 5;
    let relPos = (pc.pos - (curP * 13) + 52) % 52;
    if (relPos + steps > 50) return false; 
    return true;
}

function checkMoves(steps) {
    moving = false; 
    const pp = pieces.filter(pc => pc.p === curP && !pc.fin);
    const possible = pp.filter(pc => isValidMove(pc, steps));
    
    if(possible.length === 0) {
        document.getElementById('m').textContent = `Can't move ${steps}!`;
        diceQueue.shift();
        if(diceQueue.length > 0) {
            setTimeout(() => checkMoves(diceQueue[0]), 1000);
        } else {
            setTimeout(checkCollision, 1500, null);
        }
    } else {
        if(!humanPlayers.includes(curP)) { 
             setTimeout(() => {
                const best = possible[Math.floor(Math.random() * possible.length)];
                move(best, steps);
            }, 1000);
        } else {
            const txt = isAdditive ? `Total: ${steps}` : `Move for Die: ${steps}`;
            document.getElementById('m').textContent = `${txt} - Click piece`;
        }
    }
}

function nextTurn() {
    document.getElementById('dice-result-container').innerHTML = '';
    rolling = false;
    moving = false;
    diceQueue = []; 
    
    let loops = 0;
    do { curP = (curP + 1) % 4; loops++; } while (!activePlayers.includes(curP) && loops < 5);
    dice = [0, 0];
    document.getElementById('d').textContent = '-';
    document.getElementById('m').textContent = '';
    targetCamPos.copy(defaultCamPos);
    targetLookAt.copy(defaultLookAt);
    updateUI();
}

function getMovePath(pc, mv) {
    let path = [];
    let cPos = pc.pos; let cHIdx = pc.hIdx; let cHPath = pc.hPath; let cHome = pc.home;
    for(let i=1; i<=mv; i++) {
        let vec;
        if(cHome) {
            cHome = false; cPos = (curP * 13) % 52;
            const [bx, bz] = mainPath[cPos]; vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
        } else if(cHPath) {
            cHIdx++;
            if(cHIdx === 5) vec = new THREE.Vector3(0,0,0);
            else { 
                if(cHIdx > 5) cHIdx = 5; 
                if(homePaths[curP][cHIdx]) {
                    const [bx, bz] = homePaths[curP][cHIdx]; 
                    vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8); 
                } else {
                    vec = new THREE.Vector3(0,0,0);
                }
            }
        } else {
            let relPos = (cPos - (curP * 13) + 52) % 52;
            if(relPos + 1 > 50) {
                cHPath = true; cHIdx = 0;
                if(homePaths[curP] && homePaths[curP][0]) {
                      const [bx, bz] = homePaths[curP][0]; vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
                }
            } else {
                cPos = (cPos + 1) % 52;
                const [bx, bz] = mainPath[cPos]; vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
            }
        }
        if(vec) path.push(vec);
    }
    return path;
}

function move(pc, mv) {
    if(moving) return;
    moving = true;
    document.getElementById('dice-result-container').innerHTML = '';
    document.getElementById('m').textContent = '';
    const pathCoords = getMovePath(pc, mv);
    let hopIdx = 0;
    function animateHop() {
        if(hopIdx >= pathCoords.length) {
            let cPos = pc.pos; let cHIdx = pc.hIdx; let cHPath = pc.hPath; let cHome = pc.home;
            for(let i=1; i<=mv; i++) {
                 if(cHome) { cHome = false; cPos = (curP * 13) % 52; } 
                 else if(cHPath) { cHIdx++; } 
                 else {
                    let relPos = (cPos - (curP * 13) + 52) % 52;
                    if(relPos + 1 > 50) { cHPath = true; cHIdx = 0; } 
                    else { cPos = (cPos + 1) % 52; }
                }
            }
            pc.pos = cPos; pc.hIdx = cHIdx; pc.hPath = cHPath; pc.home = cHome;
            if(pc.hIdx === 5) { pc.fin = true; SoundGen.home(); }
            
            diceQueue.shift(); 
            checkCollision(pc); 
            return;
        }
        const start = pc.m.position.clone();
        const end = pathCoords[hopIdx];
        const mid = new THREE.Vector3().lerpVectors(start, end, 0.5);
        targetLookAt.copy(end); 
        targetCamPos.set(mid.x, 8, mid.z + 5); 

        const hopDur = 300; 
        const stT = Date.now();
        SoundGen.step();

        function stepAnim() {
             const now = Date.now();
             const pr = Math.min((now - stT) / hopDur, 1);
             pc.m.position.x = start.x + (end.x - start.x) * pr;
             pc.m.position.z = start.z + (end.z - start.z) * pr;
             pc.m.position.y = Math.sin(pr * Math.PI) * 1.5; 
             pc.m.rotation.z = Math.sin(pr * Math.PI * 2) * 0.2;
             if(pr < 1) requestAnimationFrame(stepAnim);
             else {
                 pc.m.position.copy(end);
                 pc.m.position.y = 0; pc.m.rotation.z = 0;
                 hopIdx++;
                 setTimeout(animateHop, 50); 
             }
        }
        stepAnim();
    }
    animateHop();
}

function checkCollision(pc) {
    if(pc && !pc.fin && !pc.home && !pc.hPath && !safe.includes(pc.pos)) {
        const cap = pieces.filter(p => p !== pc && !p.home && !p.fin && !p.hPath && p.pos === pc.pos && p.p !== pc.p);
        if(cap.length > 0) {
            SoundGen.capture();
            cap.forEach(p => {
                p.home = true; p.pos = -1;
                const [bx, bz] = p.hPos;
                const s = p.m.position.clone();
                const e = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
                let st = 0;
                function retAnim() {
                    st+=0.05;
                    p.m.position.lerpVectors(s, e, st);
                    p.m.position.y = Math.sin(st*Math.PI)*3;
                    p.m.rotation.y += 0.5;
                    if(st<1) requestAnimationFrame(retAnim);
                    else { p.m.position.y=0; p.m.rotation.y=0; }
                }
                retAnim();
            });
        }
    }
    
    if(pieces.filter(p => p.p === curP && p.fin).length === 4) {
        SoundGen.win();
        document.getElementById('m').innerHTML = `<span style="color:${hexColsCss[curP]}; font-size:30px;">${cols[curP]} WINS! ðŸŽ‰</span>`;
        gameActive = false;
        return;
    }
    
    if(diceQueue.length > 0) {
        moving = false;
        checkMoves(diceQueue[0]);
    } else {
        if(dice.includes(6)) {
            document.getElementById('m').textContent = 'Bonus turn for rolling 6!';
            document.getElementById('roll').disabled = false;
            dice = [0,0]; 
            moving = false; 
            targetCamPos.copy(defaultCamPos);
            if(!humanPlayers.includes(curP)) setTimeout(aiTurn, 1000);
        } else {
            setTimeout(nextTurn, 500);
        }
    }
}

const rc = new THREE.Raycaster();
const ms = new THREE.Vector2();
c.addEventListener('click', e => {
    if(rolling || moving || diceQueue.length === 0 || !humanPlayers.includes(curP)) return;
    ms.x = (e.clientX/innerWidth)*2 - 1;
    ms.y = -(e.clientY/innerHeight)*2 + 1;
    rc.setFromCamera(ms, cam);
    const ints = rc.intersectObjects(pieces.map(p=>p.m), true);
    if(ints.length > 0) {
        let o = ints[0].object;
        while(o.parent && !o.userData.isPiece) o = o.parent;
        const pc = pieces.find(p => p.m === o);
        if(pc && pc.p === curP && !pc.fin) {
            const steps = diceQueue[0];
            if(isValidMove(pc, steps)) move(pc, steps);
        }
    }
});

function render() {
    requestAnimationFrame(render);
    cam.position.lerp(targetCamPos, 0.05);
    if(!window.curLook) window.curLook = defaultLookAt.clone();
    window.curLook.lerp(targetLookAt, 0.05);
    cam.lookAt(window.curLook);
    rend.render(scene, cam);
}
window.addEventListener('resize', () => {
  cam.aspect = innerWidth/innerHeight;
  cam.updateProjectionMatrix();
  rend.setSize(innerWidth, innerHeight);
});
cam.position.copy(defaultCamPos);
cam.lookAt(defaultLookAt);
render();
</script>
</body>
</html>