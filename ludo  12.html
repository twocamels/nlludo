<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nairaland Ludo 3D - Final Version</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
  body { overflow: hidden; font-family: 'Poppins', sans-serif; background: #000; }
  #c { display: block; width: 100vw; height: 100vh; }
  
  /* UI LAYER */
  #ui-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none;
  }

  /* TITLE WITH FLAG */
  #game-title-container {
    position: absolute; top: 20px; width: 100%;
    display: flex; justify-content: center; pointer-events: none;
  }
  #game-title {
    display: flex; align-items: center; gap: 15px;
    font-size: 40px; font-weight: 900; color: white;
    text-transform: uppercase;
    background: rgba(0,0,0,0.4);
    border: 3px solid white;
    padding: 10px 30px;
    backdrop-filter: blur(4px);
    box-shadow: 0 0 20px rgba(255,255,255,0.2);
  }
  .ng-flag {
    width: 50px; height: 35px;
    background: linear-gradient(90deg, #008751 33%, #ffffff 33%, #ffffff 66%, #008751 66%);
    border: 1px solid #fff;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
  }

  /* RULES BUTTON - TOP RIGHT */
  #btn-rules {
    position: absolute; top: 30px; right: 30px;
    pointer-events: auto; z-index: 10;
  }

  /* STATUS PANEL */
  #status-panel {
    position: absolute; top: 130px; left: 20px;
    background: rgba(20, 20, 35, 0.9);
    backdrop-filter: blur(15px);
    padding: 20px; border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    color: white; font-size: 16px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
    pointer-events: none; min-width: 240px;
    transition: all 0.5s ease;
  }
  
  .player-row {
    display: flex; justify-content: space-between; padding: 6px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    opacity: 0.5; transition: all 0.3s;
  }
  .player-row.active {
    opacity: 1; font-weight: bold;
    background: linear-gradient(90deg, rgba(255,255,255,0.1), transparent);
    padding-left: 8px; border-radius: 4px; border-left: 3px solid white;
  }
  .player-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; box-shadow: 0 0 5px currentColor; }

  /* CONTROLS CONTAINER */
  #controls {
    position: absolute;
    display: flex; gap: 10px;
    pointer-events: auto;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    padding: 20px;
    background: radial-gradient(circle, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0) 70%);
    border-radius: 30px;
  }
  
  .pos-bottom-center { bottom: 40px; left: 50%; transform: translateX(-50%); flex-direction: row; }
  .pos-0 { bottom: 30px; left: 30px; flex-direction: column-reverse; } /* RED */
  .pos-1 { top: 120px; left: 30px; flex-direction: column; } /* GREEN */
  .pos-2 { top: 120px; right: 30px; flex-direction: column; align-items: flex-end;} /* YELLOW */
  .pos-3 { bottom: 30px; right: 30px; flex-direction: column-reverse; align-items: flex-end; } /* BLUE */

  button {
    padding: 15px 30px; font-size: 16px; font-weight: bold;
    font-family: 'Poppins', sans-serif; border: none; border-radius: 50px;
    cursor: pointer; color: white;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    box-shadow: 0 10px 20px rgba(0,0,0,0.4);
    transition: transform 0.1s, box-shadow 0.1s, filter 0.2s;
  }
  #roll { background: #888; transition: background 0.3s; min-width: 150px; height: 60px;}
  .btn-ui { background: #3a3a4a; border: 1px solid #555; }
  #mode-btn { min-width: 160px; border: 2px solid #667eea; }
  
  button:hover { transform: translateY(-3px); filter: brightness(1.1); }
  button:active { transform: translateY(0); }
  button:disabled { opacity: 0.7; cursor: wait; filter: grayscale(50%); transform: scale(0.98); }

  /* SETUP SCREEN */
  #setup {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, #2a2a40, #111);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    color: white; z-index: 20;
  }
  
  #gameModeSelect {
    padding: 15px 25px;
    font-size: 20px;
    border-radius: 15px;
    background: rgba(20,20,35,0.9);
    color: white;
    border: 2px solid #667eea;
    margin-bottom: 30px;
    outline: none;
    cursor: pointer;
    font-family: 'Poppins', sans-serif;
    min-width: 300px;
    text-align: center;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  #gameModeSelect option {
    background: #1a1a2e;
    color: white;
    padding: 10px;
  }
  
  /* RULES MODAL */
  #rules {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(25, 25, 40, 0.98); color: white;
    padding: 40px; border-radius: 20px; max-width: 500px; width: 90%; display: none;
    border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 20px 60px rgba(0,0,0,1); z-index: 15;
  }
  .close { float: right; cursor: pointer; font-size: 30px; color: #ff5e62; }
</style>
</head>
<body>

<div id="setup">
    <div style="display:flex; align-items:center; gap:20px; margin-bottom: 30px; border: 6px solid white; padding: 20px 40px; box-shadow: 0 0 50px rgba(255,255,255,0.2);">
        <div class="ng-flag" style="transform: scale(1.5);"></div>
        <div style="font-size: 60px; font-weight: 900; text-transform:uppercase;">NL LUDO</div>
    </div>
    
    <label style="color:#aaa; margin-bottom:10px; font-size:14px; text-transform:uppercase; letter-spacing:1px;">Select Game Mode</label>
    <select id="gameModeSelect">
        <option value="2,1">Duel (1 Player vs 1 AI)</option>
        <option value="4,1" selected>Classic (1 Player vs 3 AI)</option>
        <option value="2,2">2 Humans (PvP)</option>
        <option value="4,2">Tag Team (2 Humans vs 2 AI)</option>
        <option value="4,4">Party (4 Humans)</option>
    </select>
    
    <button class="btn-ui" style="background: linear-gradient(135deg, #667eea, #764ba2); border:none; margin-top:10px; font-size: 20px; width: 250px; padding: 20px;" onclick="startGame()">Start Game</button>
</div>

<canvas id="c"></canvas>

<div id="ui-layer">
  <div id="game-title-container">
      <div id="game-title">
          <div class="ng-flag"></div>
          <span>NL LUDO</span>
      </div>
  </div>
  
  <button id="btn-rules" class="btn-ui" onclick="document.getElementById('rules').style.display='block'">RULES</button>
  
  <div id="status-panel">
    <div style="font-size: 12px; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; color: #888; font-weight:bold;">Game Status</div>
    <div id="player-list"></div>
    <div style="margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px; text-align:center;">
        <div style="font-size: 14px; color:#aaa; margin-bottom:5px;">TOTAL ROLL</div>
        <div id="d" style="font-size: 32px; color: #ffdb58; font-weight: 900; text-shadow: 0 0 10px rgba(255, 219, 88, 0.3);">-</div>
        <div id="m" style="margin-top:10px; font-style: italic; min-height: 20px; color: #ccc; font-size: 14px;"></div>
    </div>
  </div>

  <div id="controls" class="pos-bottom-center">
    <button id="roll">ROLL DICE</button>
    <button id="mode-btn" class="btn-ui" onclick="toggleMode()">MODE: ADDITIVE</button>
    <button class="btn-ui" onclick="location.reload()">RESET</button>
  </div>
</div>

<div id="rules">
  <span class="close" onclick="this.parentElement.style.display='none'">&times;</span>
  <h2 style="color:#ff9966">How to Play</h2>
  <ul style="line-height: 1.8; margin-top: 10px; margin-left: 20px;">
    <li><b>Start:</b> You don't need a 6 to start. Any roll works!</li>
    <li><b>Safe Spots:</b> <span style="color:#bf5aff; font-weight:bold;">Purple</span> squares are safe from capture.</li>
    <li><b>Capture:</b> Land on an opponent to send them home.</li>
    <li><b>Victory:</b> Get all 4 pieces to the center triangle.</li>
    <li><b>Modes:</b> Use the toggle to switch between <b>Additive</b> (Dice Sum) or <b>Individual</b> (Split Moves).</li>
  </ul>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// --- Audio System ---
const SoundGen = {
    ctx: null,
    init: function() {
        if(!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                this.ctx = new AudioContext();
            }
        }
        if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    playNote: function(freq, type, dur, vol=0.1, slideTo=null) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slideTo) {
            osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + dur);
        }
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + dur + 0.1);
    },
    roll: function() {
        if(!this.ctx) return;
        const bufSize = this.ctx.sampleRate * 0.4;
        const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<bufSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i/(bufSize/5));
        const noise = this.ctx.createBufferSource();
        noise.buffer = buf;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass'; filter.frequency.value = 800;
        const gain = this.ctx.createGain(); gain.gain.value = 0.3;
        noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
        noise.start();
    },
    step: function() { 
        if(!this.ctx) return;
        const tones = [523.25, 587.33, 659.25, 783.99];
        const f = tones[Math.floor(Math.random()*tones.length)];
        this.playNote(f, 'sine', 0.15, 0.1); this.playNote(f*2, 'triangle', 0.1, 0.05);
    },
    home: function() { 
        if(!this.ctx) return;
        [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => { setTimeout(() => this.playNote(f, 'triangle', 0.6, 0.15), i*80); });
    },
    capture: function() { 
        if(!this.ctx) return;
        this.playNote(400, 'sine', 0.4, 0.2, 100); this.playNote(405, 'triangle', 0.4, 0.1, 105);
    },
    win: function() {
        if(!this.ctx) return;
        const scale = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1567.98];
        scale.forEach((f, i) => {
             setTimeout(() => this.playNote(f, 'square', 0.4, 0.05), i*120);
             setTimeout(() => this.playNote(f, 'triangle', 0.6, 0.1), i*120);
        });
        setTimeout(() => {
            this.playNote(523.25, 'triangle', 1.5, 0.2);
            this.playNote(659.25, 'triangle', 1.5, 0.2);
            this.playNote(783.99, 'triangle', 1.5, 0.2);
        }, scale.length*120);
    }
};

// --- Global Setup ---
const c = document.getElementById('c');
const scene = new THREE.Scene();
const bgColor = new THREE.Color(0x1a1a2e);
scene.background = bgColor;
scene.fog = new THREE.Fog(bgColor, 15, 50);

const cam = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
const rend = new THREE.WebGLRenderer({canvas:c, antialias:true});
rend.setSize(innerWidth, innerHeight);
rend.shadowMap.enabled = true;
rend.shadowMap.type = THREE.PCFSoftShadowMap;

const cols = ['RED', 'GREEN', 'YELLOW', 'BLUE'];
const hexCols = [0xff3333, 0x33ff33, 0xffff33, 0x3333ff];
const hexColsCss = ["#ff5e62", "#33ff33", "#ffff33", "#5555ff"];
const safeColorHex = 0x9933ff; 

let curP = 0; 
let humanPlayers = []; 
let dice = [0, 0];
let rolling = false; let moving = false;
let pieces = []; let board, d1, d2;
let activePlayers = []; let gameActive = false;

let isAdditive = true;
let diceQueue = [];

const defaultCamPos = new THREE.Vector3(0, 18, 14);
const defaultLookAt = new THREE.Vector3(0, 0, 0);
let targetCamPos = defaultCamPos.clone();
let targetLookAt = defaultLookAt.clone();

const mainPath=[[6,0],[6,1],[6,2],[6,3],[6,4],[6,5],[5,6],[4,6],[3,6],[2,6],[1,6],[0,6],[0,7],[0,8],
[1,8],[2,8],[3,8],[4,8],[5,8],[6,9],[6,10],[6,11],[6,12],[6,13],[6,14],[7,14],[8,14],[8,13],[8,12],
[8,11],[8,10],[8,9],[9,8],[10,8],[11,8],[12,8],[13,8],[14,8],[14,7],[14,6],[13,6],[12,6],[11,6],[10,6],
[9,6],[8,5],[8,4],[8,3],[8,2],[8,1],[8,0],[7,0]];
const homePaths={0:[[7,1],[7,2],[7,3],[7,4],[7,5],[7,6]],1:[[1,7],[2,7],[3,7],[4,7],[5,7],[6,7]],
2:[[7,13],[7,12],[7,11],[7,10],[7,9],[7,8]],3:[[13,7],[12,7],[11,7],[10,7],[9,7],[8,7]]};
const safe = [0, 8, 13, 21, 26, 34, 39, 47];

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.7);
dl.position.set(5, 20, 5); dl.castShadow = true;
dl.shadow.mapSize.width = 2048; dl.shadow.mapSize.height = 2048;
scene.add(dl);
const pl = new THREE.PointLight(0xffaa88, 0.3, 50);
pl.position.set(0, 10, 0); scene.add(pl);

function createNumCanvas(num, colorHex) {
    const cvs = document.createElement('canvas');
    cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#' + colorHex.toString(16).padStart(6,'0');
    ctx.fillRect(0,0,128,128);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 80px Arial';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor="rgba(0,0,0,0.5)"; ctx.shadowBlur=4;
    ctx.fillText(num, 64, 64);
    return new THREE.CanvasTexture(cvs);
}

function createBorderLabel(text) {
    const cvs = document.createElement('canvas');
    cvs.width = 512; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#2b1d0e'; ctx.fillRect(0,0,512,128);
    ctx.fillStyle = '#ffdb58'; ctx.font = 'bold 50px Arial';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.shadowColor = "black"; ctx.shadowBlur = 4;
    ctx.fillText(text, 256, 64);
    return new THREE.CanvasTexture(cvs);
}

function makeBoard() {
  const g = new THREE.Group();
  const floorGeo = new THREE.PlaneGeometry(200, 200);
  const floorMat = new THREE.MeshStandardMaterial({color: 0x252535, roughness: 0.8});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2; floor.position.y = -0.2; floor.receiveShadow = true;
  scene.add(floor);

  const sz = 0.8;
  const baseGeo = new THREE.BoxGeometry(13.5, 0.3, 13.5);
  const baseMat = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.2});
  const base = new THREE.Mesh(baseGeo, baseMat);
  base.receiveShadow = true; base.castShadow = true; g.add(base);
  
  const borderThick = 0.5; const boardSize = 12;
  const labelTex = createBorderLabel("NAIRALAND LUDO");
  const borderMat = new THREE.MeshStandardMaterial({map: labelTex});
  
  const b1 = new THREE.Mesh(new THREE.BoxGeometry(boardSize + borderThick*2, 0.4, borderThick), borderMat);
  b1.position.set(0, 0, boardSize/2 + borderThick/2); g.add(b1);
  const b2 = new THREE.Mesh(new THREE.BoxGeometry(boardSize + borderThick*2, 0.4, borderThick), borderMat);
  b2.position.set(0, 0, -(boardSize/2 + borderThick/2)); b2.rotation.y = Math.PI; g.add(b2);
  const b3 = new THREE.Mesh(new THREE.BoxGeometry(borderThick, 0.4, boardSize + borderThick*2), borderMat);
  b3.position.set(boardSize/2 + borderThick/2, 0, 0); b3.rotation.y = Math.PI/2; g.add(b3);
  const b4 = new THREE.Mesh(new THREE.BoxGeometry(borderThick, 0.4, boardSize + borderThick*2), borderMat);
  b4.position.set(-(boardSize/2 + borderThick/2), 0, 0); b4.rotation.y = -Math.PI/2; g.add(b4);

  const safeMat = new THREE.MeshStandardMaterial({color: safeColorHex});
  const regularMat = new THREE.MeshStandardMaterial({color: 0xdddddd});

  for(let x=0; x<15; x++){
    for(let z=0; z<15; z++){
      const px = (x-7)*sz, pz = (z-7)*sz;
      let mat = regularMat;
      let col = null;
      if(x<6 && z<6) col = 0xff6666; else if(x<6 && z>8) col = 0x66ff66;
      else if(x>8 && z>8) col = 0xffff66; else if(x>8 && z<6) col = 0x6666ff;
      const pIdx = mainPath.findIndex(p=>p[0]===x && p[1]===z);
      if(pIdx >= 0 && safe.includes(pIdx)) {
         mat = safeMat; col = null;
      }
      for(let i=0; i<4; i++) if(homePaths[i].some(p=>p[0]===x && p[1]===z)) col = hexCols[i];
      if(col !== null) mat = new THREE.MeshStandardMaterial({color: col});

      const sq = new THREE.Mesh(new THREE.BoxGeometry(sz*0.95, 0.1, sz*0.95), mat);
      sq.position.set(px, 0.2, pz); sq.receiveShadow = true; sq.castShadow = true; g.add(sq);
      if(pIdx>=0 && safe.includes(pIdx)){
        const star = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.1, 5), new THREE.MeshStandardMaterial({color: 0xffd700}));
        star.position.set(px, 0.26, pz); star.rotation.x = Math.PI/2; g.add(star);
      }
    }
  }
  
  const centerG = new THREE.Group();
  const cSz = sz * 1.4; const cHeight = 0.21;
  const sR = new THREE.Shape(); sR.moveTo(-cSz,-cSz); sR.lineTo(cSz,-cSz); sR.lineTo(0,0); sR.lineTo(-cSz,-cSz);
  const mR = new THREE.Mesh(new THREE.ShapeGeometry(sR), new THREE.MeshStandardMaterial({color: hexCols[0]}));
  mR.rotation.x = -Math.PI/2; mR.position.y = cHeight; centerG.add(mR);
  const sG = new THREE.Shape(); sG.moveTo(-cSz,cSz); sG.lineTo(-cSz,-cSz); sG.lineTo(0,0); sG.lineTo(-cSz,cSz);
  const mG = new THREE.Mesh(new THREE.ShapeGeometry(sG), new THREE.MeshStandardMaterial({color: hexCols[1]}));
  mG.rotation.x = -Math.PI/2; mG.position.y = cHeight; centerG.add(mG);
  const sY = new THREE.Shape(); sY.moveTo(cSz,cSz); sY.lineTo(-cSz,cSz); sY.lineTo(0,0); sY.lineTo(cSz,cSz);
  const mY = new THREE.Mesh(new THREE.ShapeGeometry(sY), new THREE.MeshStandardMaterial({color: hexCols[2]}));
  mY.rotation.x = -Math.PI/2; mY.position.y = cHeight; centerG.add(mY);
  const sB = new THREE.Shape(); sB.moveTo(cSz,-cSz); sB.lineTo(cSz,cSz); sB.lineTo(0,0); sB.lineTo(cSz,-cSz);
  const mB = new THREE.Mesh(new THREE.ShapeGeometry(sB), new THREE.MeshStandardMaterial({color: hexCols[3]}));
  mB.rotation.x = -Math.PI/2; mB.position.y = cHeight; centerG.add(mB);
  g.add(centerG);
  const finalPt = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,0.05,16), new THREE.MeshBasicMaterial({color:0xffffff}));
  finalPt.position.y = 0.22; g.add(finalPt);
  return g;
}

function makeDice() {
  const g = new THREE.Group();
  const cube = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({color: 0xffffff}));
  cube.castShadow = true; g.add(cube);
  const dotMat = new THREE.MeshStandardMaterial({color:0x000000});
  const positions = [[[0,0,0.41]],[[-0.2,0.2,0.41],[0.2,-0.2,0.41]],[[-0.2,0.2,0.41],[0,0,0.41],[0.2,-0.2,0.41]],[[-0.2,0.2,0.41],[0.2,0.2,0.41],[-0.2,-0.2,0.41],[0.2,-0.2,0.41]],[[-0.2,0.2,0.41],[0.2,0.2,0.41],[0,0,0.41],[-0.2,-0.2,0.41],[0.2,-0.2,0.41]],[[-0.2,0.25,0.41],[0.2,0.25,0.41],[-0.2,0,0.41],[0.2,0,0.41],[-0.2,-0.25,0.41],[0.2,-0.25,0.41]]];
  const rots = [[0,0,0],[0,Math.PI,0],[0,-Math.PI/2,0],[0,Math.PI/2,0],[-Math.PI/2,0,0],[Math.PI/2,0,0]];
  for(let i=0; i<6; i++){
    const face = new THREE.Group();
    positions[i].forEach(p => {
      const dot = new THREE.Mesh(new THREE.SphereGeometry(0.06), dotMat);
      dot.position.set(...p); face.add(dot);
    });
    face.rotation.set(...rots[i]); g.add(face);
  }
  return g;
}

function addPathArrows() {
    const arrowGeo = new THREE.ConeGeometry(0.12, 0.3, 8);
    const arrowMat = new THREE.MeshBasicMaterial({color: 0xffffff}); 
    for(let i=0; i<mainPath.length; i++) {
        let nextIdx = (i + 1) % mainPath.length;
        const [cx, cz] = mainPath[i]; const [nx, nz] = mainPath[nextIdx];
        const arrow = new THREE.Mesh(arrowGeo, arrowMat);
        arrow.position.set((cx-7)*0.8, 0.26, (cz-7)*0.8); 
        arrow.lookAt((nx-7)*0.8, 0.26, (nz-7)*0.8);
        arrow.rotation.x = Math.PI/2; 
        arrow.lookAt((nx-7)*0.8, 0.26, (nz-7)*0.8);
        arrow.rotateX(Math.PI/2);
        board.add(arrow);
    }
    const entryPoints = [mainPath[50], mainPath[11], mainPath[24], mainPath[37]]; 
    const homeStarts = [homePaths[0][0], homePaths[1][0], homePaths[2][0], homePaths[3][0]];
    for(let p=0; p<4; p++) {
        const cMat = new THREE.MeshBasicMaterial({color: hexCols[p]});
        const [cx, cz] = entryPoints[p]; const [hx, hz] = homeStarts[p];
        const arrow = new THREE.Mesh(arrowGeo, cMat);
        const midX = (cx + hx) / 2; const midZ = (cz + hz) / 2;
        arrow.position.set((midX-7)*0.8, 0.26, (midZ-7)*0.8);
        arrow.lookAt((hx-7)*0.8, 0.26, (hz-7)*0.8);
        arrow.rotateX(Math.PI/2); arrow.scale.set(1.5,1.5,1.5);
        board.add(arrow);
    }
}

board = makeBoard();
addPathArrows(); 
scene.add(board);
d1 = makeDice(); d2 = makeDice();
d1.position.set(-8, 1, 0); d2.position.set(-8, 1, 1.5);
scene.add(d1, d2);

const homes = [[[1.5,1.5],[1.5,4.5],[4.5,1.5],[4.5,4.5]],[[1.5,9.5],[1.5,12.5],[4.5,9.5],[4.5,12.5]],
  [[9.5,9.5],[9.5,12.5],[12.5,9.5],[12.5,12.5]],[[9.5,1.5],[9.5,4.5],[12.5,1.5],[12.5,4.5]]];

function initPieces() {
    pieces = [];
    scene.children.filter(c => c.userData.isPiece).forEach(c => scene.remove(c));
    activePlayers.forEach(p => {
      for(let i=0; i<4; i++){
        const g = new THREE.Group();
        g.userData.isPiece = true;
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.5, 16), new THREE.MeshStandardMaterial({color: hexCols[p]}));
        cyl.castShadow = true; cyl.position.y = 0.25; g.add(cyl);
        const top = new THREE.Mesh(new THREE.SphereGeometry(0.25, 32, 32), new THREE.MeshStandardMaterial({
            map: createNumCanvas(i+1, hexCols[p]), color: 0xffffff
        }));
        top.rotation.y = -Math.PI/2; top.rotation.x = -Math.PI/4; top.position.y = 0.6; top.castShadow = true;
        g.add(top);
        const [bx, bz] = homes[p][i];
        g.position.set((bx-7)*0.8, 0, (bz-7)*0.8);
        g.userData.player = p; g.userData.id = i;
        scene.add(g);
        pieces.push({
            m: g, p: p, id: i,
            pos: -1, home: true, hPath: false, hIdx: -1, 
            hPos: [bx, bz], fin: false
        });
      }
    });
}

function toggleMode() {
    isAdditive = !isAdditive;
    const btn = document.getElementById('mode-btn');
    if(isAdditive) {
        btn.innerText = "MODE: ADDITIVE";
        btn.style.borderColor = "#667eea"; btn.style.color = "white";
    } else {
        btn.innerText = "MODE: INDIVIDUAL";
        btn.style.borderColor = "#ff9966"; btn.style.color = "#ff9966";
    }
}

function startGame() {
    try {
        SoundGen.init(); 
        const selVal = document.getElementById('gameModeSelect').value;
        const [tVal, hVal] = selVal.split(',');
        const totalP = parseInt(tVal);
        const humanCount = parseInt(hVal);
        
        // --- RANDOM COLOR ASSIGNMENT LOGIC ---
        activePlayers = [];
        for(let i=0; i<totalP; i++) activePlayers.push(i);
        
        // Shuffle logic for humans
        let pool = [...activePlayers];
        humanPlayers = [];
        for(let k=0; k<humanCount; k++) {
            let randIdx = Math.floor(Math.random() * pool.length);
            humanPlayers.push(pool[randIdx]);
            pool.splice(randIdx, 1);
        }
        humanPlayers.sort(); 
        
        document.getElementById('setup').style.display = 'none';
        gameActive = true;
        initPieces();
        curP = 0; 
        updateUI();
        SoundGen.roll();
    } catch(e) {
        console.error("Game Start Error:", e);
        alert("Error starting game.");
    }
}

function updateUI() {
    const list = document.getElementById('player-list');
    list.innerHTML = '';
    for(let i=0; i<4; i++) {
        const div = document.createElement('div');
        div.className = 'player-row';
        if(i === curP) div.classList.add('active');
        let status = "VACANT";
        if(activePlayers.includes(i)) status = (humanPlayers.includes(i)) ? "HUMAN" : "AI";
        const colDiv = document.createElement('div');
        colDiv.innerHTML = `<span class="player-indicator" style="background:${hexColsCss[i]}"></span>${cols[i]}`;
        const statDiv = document.createElement('div'); statDiv.innerText = status;
        div.appendChild(colDiv); div.appendChild(statDiv); list.appendChild(div);
    }
    const btn = document.getElementById('roll');
    btn.style.background = hexColsCss[curP];
    btn.style.color = (curP === 2) ? "#000" : "#fff"; 
    btn.style.textShadow = (curP === 2) ? "none" : "0 2px 4px rgba(0,0,0,0.5)";
    
    const ctrls = document.getElementById('controls');
    
    if(humanPlayers.length > 1) {
        ctrls.className = ''; 
        ctrls.classList.add(`pos-${curP}`);
    } else {
        ctrls.className = 'pos-bottom-center';
    }

    if(!humanPlayers.includes(curP) && gameActive) {
        btn.disabled = true; btn.textContent = "AI TURN...";
        setTimeout(aiTurn, 1000);
    } else {
        btn.disabled = false; btn.textContent = `ROLL DICE`;
    }
}

document.getElementById('roll').onclick = () => {
    // BLOCK ONLY IF moving flag is validly set for a move animation
    // But if dice exist (bonus turn), we allow it.
    if(rolling || moving || (dice[0]!==0 && diceQueue.length > 0)) return;
    performRoll();
};

function aiTurn() { performRoll(); }

function performRoll() {
    diceQueue = [];
    SoundGen.roll();
    rolling = true;
    document.getElementById('roll').disabled = true;
    let sp = 0;
    targetCamPos.copy(defaultCamPos);
    targetLookAt.copy(defaultLookAt);

    const iv = setInterval(() => {
        d1.rotation.x += 0.5; d1.rotation.z += 0.3;
        d2.rotation.x += 0.3; d2.rotation.z += 0.5;
        d1.position.y = 1 + Math.sin(sp)*0.5;
        d2.position.y = 1 + Math.cos(sp)*0.5;
        if(++sp > 20){
            clearInterval(iv);
            dice = [Math.ceil(Math.random()*6), Math.ceil(Math.random()*6)];
            d1.position.set(-8, 1, 0); d2.position.set(-8, 1, 1.5);
            const faceRots = [[0,0,0],[0,Math.PI,0],[0,Math.PI/2,0],[0,-Math.PI/2,0],[-Math.PI/2,0,0],[Math.PI/2,0,0]];
            function alignDice(mesh, val) {
                mesh.rotation.set(0,0,0);
                mesh.rotateX(faceRots[val-1][0]); mesh.rotateY(faceRots[val-1][1]); mesh.rotateZ(faceRots[val-1][2]);
                mesh.lookAt(cam.position);
            }
            alignDice(d1, dice[0]); alignDice(d2, dice[1]);
            const t = dice[0] + dice[1];
            document.getElementById('d').textContent = `${dice[0]} + ${dice[1]} = ${t}`;
            rolling = false;
            
            if(isAdditive) {
                diceQueue = [dice[0] + dice[1]];
            } else {
                diceQueue = [dice[0], dice[1]];
            }
            checkMoves(diceQueue[0]);
        }
    }, 50);
}

function isValidMove(pc, steps) {
    if(pc.home) return true;
    if(pc.fin) return false;
    if(pc.hPath) return (pc.hIdx + steps) <= 5;
    let relPos = (pc.pos - (curP * 13) + 52) % 52;
    if (relPos + steps > 56) return false;
    return true;
}

function checkMoves(steps) {
    moving = false; // Reset here usually
    const pp = pieces.filter(pc => pc.p === curP && !pc.fin);
    const possible = pp.filter(pc => isValidMove(pc, steps));
    
    if(possible.length === 0) {
        document.getElementById('m').textContent = `Can't move ${steps}!`;
        diceQueue.shift();
        if(diceQueue.length > 0) {
            setTimeout(() => checkMoves(diceQueue[0]), 1000);
        } else {
            setTimeout(checkCollision, 1500, null);
        }
    } else {
        if(!humanPlayers.includes(curP)) { 
             setTimeout(() => {
                const best = possible[Math.floor(Math.random() * possible.length)];
                move(best, steps);
            }, 1000);
        } else {
            const txt = isAdditive ? `Total: ${steps}` : `Move for Die: ${steps}`;
            document.getElementById('m').textContent = `${txt} - Click piece`;
        }
    }
}

function nextTurn() {
    rolling = false;
    moving = false;
    diceQueue = []; 
    
    let loops = 0;
    do { curP = (curP + 1) % 4; loops++; } while (!activePlayers.includes(curP) && loops < 5);
    dice = [0, 0];
    document.getElementById('d').textContent = '-';
    document.getElementById('m').textContent = '';
    targetCamPos.copy(defaultCamPos);
    targetLookAt.copy(defaultLookAt);
    updateUI();
}

function getMovePath(pc, mv) {
    let path = [];
    let cPos = pc.pos; let cHIdx = pc.hIdx; let cHPath = pc.hPath; let cHome = pc.home;
    for(let i=1; i<=mv; i++) {
        let vec;
        if(cHome) {
            cHome = false; cPos = (curP * 13) % 52;
            const [bx, bz] = mainPath[cPos]; vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
        } else if(cHPath) {
            cHIdx++;
            if(cHIdx === 5) vec = new THREE.Vector3(0,0,0);
            else { 
                if(cHIdx > 5) cHIdx = 5; 
                if(homePaths[curP][cHIdx]) {
                    const [bx, bz] = homePaths[curP][cHIdx]; 
                    vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8); 
                } else {
                    vec = new THREE.Vector3(0,0,0);
                }
            }
        } else {
            let relPos = (cPos - (curP * 13) + 52) % 52;
            if(relPos + 1 > 50) {
                cHPath = true; cHIdx = 0;
                if(homePaths[curP] && homePaths[curP][0]) {
                      const [bx, bz] = homePaths[curP][0]; vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
                }
            } else {
                cPos = (cPos + 1) % 52;
                const [bx, bz] = mainPath[cPos]; vec = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
            }
        }
        if(vec) path.push(vec);
    }
    return path;
}

function move(pc, mv) {
    if(moving) return;
    moving = true;
    document.getElementById('m').textContent = '';
    const pathCoords = getMovePath(pc, mv);
    let hopIdx = 0;
    function animateHop() {
        if(hopIdx >= pathCoords.length) {
            let cPos = pc.pos; let cHIdx = pc.hIdx; let cHPath = pc.hPath; let cHome = pc.home;
            for(let i=1; i<=mv; i++) {
                 if(cHome) { cHome = false; cPos = (curP * 13) % 52; } 
                 else if(cHPath) { cHIdx++; } 
                 else {
                    let relPos = (cPos - (curP * 13) + 52) % 52;
                    if(relPos + 1 > 50) { cHPath = true; cHIdx = 0; } 
                    else { cPos = (cPos + 1) % 52; }
                }
            }
            pc.pos = cPos; pc.hIdx = cHIdx; pc.hPath = cHPath; pc.home = cHome;
            if(pc.hIdx === 5) { pc.fin = true; SoundGen.home(); }
            
            diceQueue.shift(); 
            checkCollision(pc); 
            return;
        }
        const start = pc.m.position.clone();
        const end = pathCoords[hopIdx];
        const mid = new THREE.Vector3().lerpVectors(start, end, 0.5);
        targetLookAt.copy(end); 
        targetCamPos.set(mid.x, 8, mid.z + 5); 

        const hopDur = 300; 
        const stT = Date.now();
        SoundGen.step();

        function stepAnim() {
             const now = Date.now();
             const pr = Math.min((now - stT) / hopDur, 1);
             pc.m.position.x = start.x + (end.x - start.x) * pr;
             pc.m.position.z = start.z + (end.z - start.z) * pr;
             pc.m.position.y = Math.sin(pr * Math.PI) * 1.5; 
             pc.m.rotation.z = Math.sin(pr * Math.PI * 2) * 0.2;
             if(pr < 1) requestAnimationFrame(stepAnim);
             else {
                 pc.m.position.copy(end);
                 pc.m.position.y = 0; pc.m.rotation.z = 0;
                 hopIdx++;
                 setTimeout(animateHop, 50); 
             }
        }
        stepAnim();
    }
    animateHop();
}

function checkCollision(pc) {
    if(pc && !pc.fin && !pc.home && !pc.hPath && !safe.includes(pc.pos)) {
        const cap = pieces.filter(p => p !== pc && !p.home && !p.fin && !p.hPath && p.pos === pc.pos && p.p !== pc.p);
        if(cap.length > 0) {
            SoundGen.capture();
            cap.forEach(p => {
                p.home = true; p.pos = -1;
                const [bx, bz] = p.hPos;
                const s = p.m.position.clone();
                const e = new THREE.Vector3((bx-7)*0.8, 0, (bz-7)*0.8);
                let st = 0;
                function retAnim() {
                    st+=0.05;
                    p.m.position.lerpVectors(s, e, st);
                    p.m.position.y = Math.sin(st*Math.PI)*3;
                    p.m.rotation.y += 0.5;
                    if(st<1) requestAnimationFrame(retAnim);
                    else { p.m.position.y=0; p.m.rotation.y=0; }
                }
                retAnim();
            });
        }
    }
    
    if(pieces.filter(p => p.p === curP && p.fin).length === 4) {
        SoundGen.win();
        document.getElementById('m').innerHTML = `<span style="color:${hexColsCss[curP]}; font-size:30px;">${cols[curP]} WINS! ðŸŽ‰</span>`;
        gameActive = false;
        return;
    }
    
    if(diceQueue.length > 0) {
        moving = false;
        checkMoves(diceQueue[0]);
    } else {
        if(dice.includes(6)) {
            document.getElementById('m').textContent = 'Bonus turn for rolling 6!';
            document.getElementById('roll').disabled = false;
            
            // --- CRITICAL FIX: RESET LOGIC FOR BONUS ROLL ---
            dice = [0,0]; // 1. Clear dice so click handler allows roll
            moving = false; // 2. Explicitly clear moving flag so click handler allows roll
            
            targetCamPos.copy(defaultCamPos);
            if(!humanPlayers.includes(curP)) setTimeout(aiTurn, 1000);
        } else {
            setTimeout(nextTurn, 500);
        }
    }
}

const rc = new THREE.Raycaster();
const ms = new THREE.Vector2();
c.addEventListener('click', e => {
    if(rolling || moving || diceQueue.length === 0 || !humanPlayers.includes(curP)) return;
    ms.x = (e.clientX/innerWidth)*2 - 1;
    ms.y = -(e.clientY/innerHeight)*2 + 1;
    rc.setFromCamera(ms, cam);
    const ints = rc.intersectObjects(pieces.map(p=>p.m), true);
    if(ints.length > 0) {
        let o = ints[0].object;
        while(o.parent && !o.userData.isPiece) o = o.parent;
        const pc = pieces.find(p => p.m === o);
        if(pc && pc.p === curP && !pc.fin) {
            const steps = diceQueue[0];
            if(isValidMove(pc, steps)) move(pc, steps);
        }
    }
});

function render() {
    requestAnimationFrame(render);
    cam.position.lerp(targetCamPos, 0.05);
    if(!window.curLook) window.curLook = defaultLookAt.clone();
    window.curLook.lerp(targetLookAt, 0.05);
    cam.lookAt(window.curLook);
    rend.render(scene, cam);
}
window.addEventListener('resize', () => {
  cam.aspect = innerWidth/innerHeight;
  cam.updateProjectionMatrix();
  rend.setSize(innerWidth, innerHeight);
});
cam.position.copy(defaultCamPos);
cam.lookAt(defaultLookAt);
render();
</script>
</body>
</html>